{
  "version": 3,
  "sources": ["../src/common/util.ts", "../src/common/color.ts", "../src/dither/canvas.ts", "../src/dither/basecanvas.ts", "../src/dither/dithertron.ts", "../src/worker/worker.ts"],
  "sourcesContent": ["\nexport function hex(v: number, nd?: number) {\n    if (!nd) nd = 2;\n    return toradix(v, nd, 16);\n}\n\nexport function toradix(v: number, nd: number, radix: number) {\n    try {\n        var s = v.toString(radix).toUpperCase();\n        while (s.length < nd)\n            s = \"0\" + s;\n        return s;\n    } catch (e) {\n        return v + \"\";\n    }\n}\n\nexport function sqr(x: number) { return x * x; }\n\nexport function range(start: number, end: number): number[] {\n    var arr = [];\n    for (var i = start; i < end; i++) { arr.push(i); }\n    return arr;\n}\n\nexport function stringToByteArray(s: string): Uint8Array {\n    var a = new Uint8Array(s.length);\n    for (var i = 0; i < s.length; i++)\n        a[i] = s.charCodeAt(i);\n    return a;\n}\n", "import { RGBDistanceFunction } from \"./types\";\nimport { range, sqr } from \"./util\";\n\nexport interface ColorChoice {\n    ind: number;\n    count: number;\n}\n\nexport class Centroid {\n    r: number = 0;\n    g: number = 0;\n    b: number = 0;\n    n: number = 0;\n    add(rgb: number) {\n        this.r += (rgb >> 0) & 0xff;\n        this.g += (rgb >> 8) & 0xff;\n        this.b += (rgb >> 16) & 0xff;\n        this.n++;\n    }\n    getAvgRGB(k: number) {\n        var r = Math.max(0, Math.min(255, this.r * k / this.n));\n        var g = Math.max(0, Math.min(255, this.g * k / this.n));\n        var b = Math.max(0, Math.min(255, this.b * k / this.n));\n        return (r << 0) | (g << 8) | (b << 16);\n    }\n}\n\nexport function reducePaletteChoices(imageData: Uint32Array, \n    colors: Uint32Array, \n    count: number, \n    diversity: number,\n    distfn: RGBDistanceFunction) : ColorChoice[] \n{\n    var histo = new Int32Array(colors.length);\n    var err = new Int32Array(4);\n    var tmp = new Uint8ClampedArray(4);\n    var tmp2 = new Uint32Array(tmp.buffer);\n    var bias = diversity*0.5 + 0.5;\n    let decay = diversity*0.25 + 0.65;\n    // choose initial centroids from palette\n    var centroids : Centroid[] = [];\n    var inds : number[] = [];\n    for (let i=0; i<count; i++) {\n        inds.push(Math.floor(i * (colors.length-1) / count));\n        centroids.push(new Centroid());\n    }\n    // iterate over the frame a max. number of items\n    for (let iter=0; iter<10; iter++) {\n        // iterate over pixels, skipping some for performance\n        for (let i=iter; i<imageData.length; i+=(i&15)+1) {\n            let rgbref = imageData[i];\n            err[0] += rgbref & 0xff;\n            err[1] += (rgbref >> 8) & 0xff;\n            err[2] += (rgbref >> 16) & 0xff;\n            tmp[0] = err[0];\n            tmp[1] = err[1];\n            tmp[2] = err[2];\n            let ind1 = getClosestRGB(tmp2[0], inds, colors, distfn);\n            let alt = colors[ind1];\n            centroids[inds.indexOf(ind1)].add(tmp2[0]);\n            let score = distfn(tmp2[0], alt);\n            histo[ind1] += Math.max(0, 256 - score);\n            err[0] -= (alt & 0xff);\n            err[1] -= ((alt >> 8) & 0xff);\n            err[2] -= ((alt >> 16) & 0xff);\n            err[0] *= decay;\n            err[1] *= decay;\n            err[2] *= decay;\n        }\n        // move colors if the new one is better\n        var allinds = range(0, colors.length);\n        var nchanged = 0;\n        for (let i=0; i<count; i++) {\n            // find closest palette color to centroid mean\n            let cent = centroids[i];\n            let current = colors[inds[i]];\n            let ind2 = getClosestRGB(cent.getAvgRGB(bias), allinds, colors, distfn);\n            let better = colors[ind2];\n            // if it's different, update the color\n            if (better != current) {\n                inds[i] = ind2;\n                nchanged++;\n                //console.log(iter, i, inds[i], ind2, score);\n            }\n            // don't use this color again\n            for (let j=0; j<colors.length; j++) {\n                if (colors[j] == better) { allinds[j] = -1; }\n            }\n        }\n        if (nchanged == 0) break;\n    }\n    // sort resulting colors by intensity\n    var result = inds.map((ind) => { return {ind, count:histo[ind]} });\n    result.sort((a,b) => intensity(colors[a.ind]) - intensity(colors[b.ind]));\n    return result;\n}\n\nexport function reducePalette(imageData: Uint32Array,\n    colors: Uint32Array,\n    count: number,\n    diversity: number,\n    distfn : RGBDistanceFunction) : Uint32Array \n{\n    if (colors.length == count) return new Uint32Array(colors);\n    var choices = reducePaletteChoices(imageData, colors, count, diversity, distfn);\n    console.log('reducePalette', colors.length, 'to', choices.length);\n    return new Uint32Array(choices.map((x) => colors[x.ind]));\n}\n\n//\n\nexport function getRGBADiff(rgbref: number, rgbimg: number) {\n    var err = [0,0,0];\n    for (var i=0; i<3; i++) {\n        var d = (rgbref & 0xff) - (rgbimg & 0xff);\n        err[i] = d;\n        rgbref >>= 8;\n        rgbimg >>= 8;\n    }\n    return err;\n}\n\nexport function getRGBAErrorAbsolute(rgbref: number, rgbimg: number) {\n    var mag = 0;\n    for (var i=0; i<3; i++) {\n        var d = (rgbref & 0xff) - (rgbimg & 0xff);\n        mag += sqr(d);\n        rgbref >>= 8;\n        rgbimg >>= 8;\n    }\n    return Math.sqrt(mag);\n}\n\n// TODO???\nexport function getRGBAErrorHue(rgbref: number, rgbimg: number) {\n    var r1 = ((rgbref>>0) & 0xff);\n    var g1 = ((rgbref>>8) & 0xff);\n    var b1 = ((rgbref>>16) & 0xff);\n    var r2 = ((rgbimg>>0) & 0xff);\n    var g2 = ((rgbimg>>8) & 0xff);\n    var b2 = ((rgbimg>>16) & 0xff);\n    var b = 256;\n    var avg1 = (r1+g1+b1)/3 + b;\n    var avg2 = (r2+g2+b2)/3 + b;\n    r1 /= avg1;\n    g1 /= avg1;\n    b1 /= avg1;\n    r2 /= avg2;\n    g2 /= avg2;\n    b2 /= avg2;\n    //var mag2 = Math.sqrt(sqr(r1-r2)*9 + sqr(g1-g2)*25 + sqr(b1-b2)*4);\n    //var mag2 = Math.sqrt(sqr(r1-r2)*3 + sqr(g1-g2)*5 + sqr(b1-b2)*3);\n    var mag2 = Math.sqrt(sqr(r1-r2) + sqr(g1-g2) + sqr(b1-b2))*256;\n    return mag2;\n}\n\nexport function getRGBAErrorPerceptual(rgbref: number, rgbimg: number) {\n    var r1 = ((rgbref>>0) & 0xff);\n    var g1 = ((rgbref>>8) & 0xff);\n    var b1 = ((rgbref>>16) & 0xff);\n    var r2 = ((rgbimg>>0) & 0xff);\n    var g2 = ((rgbimg>>8) & 0xff);\n    var b2 = ((rgbimg>>16) & 0xff);\n    var rmean = (r1 + r2) / 2;\n    var r = r1 - r2;\n    var g = g1 - g2;\n    var b = b1 - b2;\n    return Math.sqrt((((512+rmean)*r*r)/256) + 4*g*g + (((767-rmean)*b*b)/256));\n}\n\nexport function getRGBAErrorMax(rgbref: number, rgbimg: number) {\n    var r1 = ((rgbref>>0) & 0xff);\n    var g1 = ((rgbref>>8) & 0xff);\n    var b1 = ((rgbref>>16) & 0xff);\n    var r2 = ((rgbimg>>0) & 0xff);\n    var g2 = ((rgbimg>>8) & 0xff);\n    var b2 = ((rgbimg>>16) & 0xff);\n    return Math.max(Math.abs(r1-r2), Math.abs(g1-g2), Math.abs(b1-b2));\n}\n\nexport function intensity(rgb: number) {\n    return getRGBAErrorPerceptual(0, rgb);\n}\n\nexport const ERROR_FUNCTIONS = {\n    'perceptual': getRGBAErrorPerceptual,\n    'hue': getRGBAErrorHue,\n    'dist': getRGBAErrorAbsolute,\n    'max': getRGBAErrorMax,\n}\n\nexport function getRGBAErrorArr(a: number, b: number) {\n    var err = [0,0,0];\n    for (var i=0; i<3; i++) {\n        err[i] = ((a & 0xff) - (b & 0xff));\n        a >>= 8;\n        b >>= 8;\n    }\n    return err;\n}\n\nexport function getClosestRGB(rgb:number, inds:number[], pal:Uint32Array, distfn:RGBDistanceFunction) {\n    var best = 9999999;\n    var bestidx = -1;\n    for (var i=0; i<inds.length; i++) {\n        let ind = inds[i];\n        if (ind >= 0) {\n            var col = pal[inds[i]];\n            var score = distfn(rgb, col);\n            if (score < best) {\n                best = score;\n                bestidx = inds[i];\n            }\n        }\n    }\n    return bestidx;\n}\n\nexport function scoreRGBDistances(rgb:number, inds:number[], pal:Uint32Array, distfn:RGBDistanceFunction) {\n    let scores = [];\n    for (let i=0; i<inds.length; i++) {\n        var col = pal[inds[i]];\n        var score = distfn(rgb, col);\n        scores[i] = {i, ind:inds[i], rgb, col, score};\n    }\n    return scores;\n}\n\n//\n\nexport function getHistogram(inds: number[]) {\n    var histo = new Uint32Array(256);\n    inds.forEach((x) => histo[x]++);\n    return getChoices(histo);\n}\n\nexport function getChoices(histo: Uint32Array) {\n    var choices : {count:number,ind:number}[] = [];\n    for (var i=0; i<histo.length; i++) {\n        if (histo[i] > 0) {\n            choices.push({count:histo[i], ind:i});\n        }\n    }\n    choices.sort((a,b) => b.count - a.count);\n    return choices;\n}\n\nexport function rgb2tuple(arr: number[]) {\n    return arr.map((x) => [(x>>0) & 0xff, (x>>8) & 0xff, (x>>16) & 0xff]);\n}\n\nexport function convertToSystemPalette(pal: Uint32Array, syspal: Uint32Array | number[]) {\n    return pal.map((rgba) => syspal.indexOf(rgba & 0xffffff));\n}\n\n", "import { getChoices, reducePaletteChoices, ColorChoice } from \"../common/color\";\nimport { PaletteChoices, PaletteRange  } from \"../common/types\";\nimport { BaseDitheringCanvas, BasicParamDitherCanvas, OneColor_Canvas, ParamDitherCanvas, TwoColor_Canvas } from \"./basecanvas\";\nimport { MAX_ITERATE_COUNT } from \"./dithertron\";\n\nexport class DitheringCanvas extends BaseDitheringCanvas {\n    // just a wrapper for the base class so we can find it\n}\n\nexport class Teletext_Canvas extends OneColor_Canvas {\n    w = 2;\n    h = 3;\n}\nexport class VDPMode2_Canvas extends TwoColor_Canvas {\n    w = 8;\n    h = 1;\n}\nexport class VCSColorPlayfield_Canvas extends TwoColor_Canvas {\n    w = 40;\n    h = 1;\n}\nexport class ZXSpectrum_Canvas extends TwoColor_Canvas {\n    w = 8;\n    h = 8;\n}\nexport class Compucolor_Canvas extends TwoColor_Canvas {\n    w = 2;\n    h = 4;\n}\n\nexport class Apple2_Canvas extends TwoColor_Canvas {\n    w = 7;\n    h = 1;\n    allColors = [0, 1, 2, 3, 4, 5];\n    guessParam(p: number) {\n        var offset = p * this.w;\n        var colors = this.allColors;\n        var histo = new Uint32Array(16);\n        for (var i = 0; i < this.w; i++) {\n            var c1 = this.indexed[offset + i] | 0;\n            histo[c1] += 100;\n            var c2 = this.getClosest(this.alt[offset + i] | 0, colors);\n            histo[c2] += 1 + this.noise;\n        }\n        var hibit = histo[3] + histo[4] > histo[1] + histo[2];\n        this.params[p] = hibit ? 1 : 0;\n    }\n    getValidColors(offset: number) {\n        var i = Math.floor(offset / this.w);\n        var hibit = (this.params[i] & 1) != 0;\n        // hi bit set? (covers 2 bytes actually)\n        if (hibit)\n            return [0, 3, 4, 5];\n        else\n            return [0, 1, 2, 5];\n    }\n}\n\nnamespace VICII_Canvas_Details {\n    export interface UseBlockInfo {\n        w: number;\n        h: number;\n        xb?: number;\n        yb?: number;\n    };\n\n    export let prepare = function (defaults: UseBlockInfo, block?: UseBlockInfo): UseBlockInfo {\n        if (block === undefined) {\n            return prepare(defaults, defaults);\n        }\n        let result: UseBlockInfo = { ...block };\n        result.xb = (block.xb === undefined ? 0 : block.xb);\n        result.yb = (block.yb === undefined ? 0 : block.yb);\n        return result;\n    }\n}\n\nexport class VICII_Canvas extends ParamDitherCanvas {\n    // FLI allows for the color choices of pixel values %01/%10 to change PER row as the\n    // screen address where the color information is stored is changeable for each scan line\n    // BUT the color ram for the %11 is not an address that can be changed so the\n    // color ram applies to the entire 4x8 macro block\n\n    // pixel values (for multi-mode):\n    // %00 = background color (global value)\n    // %01 = upper nybble of screen block (changeable per row 4x8 block size, 4x1 in FLI)\n    // %10 = lower nybble of screen block (changeable only at the 4x8 block size)\n    // %11 = lower nybble of color ram\n\n    // pixel values (for hires-mode):\n    // %0 = background color choice (stored in screen lower nybble, changeable per 8x8 block, 8x1 in FLI)\n    // %1 = color choice (stored in screen upper nybble, changeable per 8x8 block, 8x1 in FLI)\n    b: VICII_Canvas_Details.UseBlockInfo;\n    colors: number;\n\n    paletteChoices: PaletteChoices = {};\n    pixelPaletteChoices: number[];\n\n    // NOTE: cb = \"color block\"\n    //\n    // In multi-color mode, the pixel index color choices are either %00 for background,\n    // %10 lower nybble screen value, %01 for upper nybble screen value, and %11 for\n    // the color block. The color block values are kept as a separate set of parameters\n    // at the end of the screen color choice parameters as they are an entirely\n    // independent color choice data set which is immovable in memory (unlike screen\n    // ram which is address moveable). The block size of the color blocks (4x8) happen to\n    // be the same size as the screen color choice block sizes (4x8) in multi-color mode.\n    // However, in multi-color FLI mode the screen color choices have per row color\n    // choices (4x1) even though the color block sizes remain the same size (4x8).\n    //\n    // This the reason the color block parameters are split from the screen parameter\n    // color choices as they are not always a 1:1 pairing.\n    useCb: boolean;\n    cb: VICII_Canvas_Details.UseBlockInfo;\n    cbOffset: number = 0;   // the offset into the params array for the color block ram\n\n    bitsPerColor: number;\n    pixelsPerByte: number;\n\n    fliMode: boolean = false;\n\n    // FLI mode causes a VIC bug to appear coined the \"fli bug\". The issue is that\n    // when $D011 is forced into a \"bad line\" condition which forces the VIC to\n    // refetch color data and the CPU stalls the VIC long enough that exactly 3 character\n    // values wide lack proper color block data (they instead use left over color block\n    // data from the previous raster line).\n    //\n    // Whenever the vertical scroll register $D011 lower 3-bits match the current\n    // raster line number's lower 3 bits, the VIC is forced to re-fetch color block data.\n    // Under normal VIC/CPU conditions this happens every 8 raster lines because the\n    // vertical scroll value has 8 possible values and thus the raster line bits match\n    // the vertical scroll bits once in every 8 raster lines.\n    //\n    // Normally the VIC detects this condition while still inside the H-blank thus no\n    // problem occurs. However, the FLI logic needs to swap the $D011 register's scroll\n    // value every single scan line and re-adjust the screen data memory address, then\n    // loop. This forces the VIC to enter a \"bad line\" state at improper timing than\n    // normal conditions and the VIC must re-fetch the color block data. Worse, the\n    // CPU timings require the VIC wait a 3-cycle handoff period prior to fetching the\n    // color block data. Thus while the VIC is waiting, it still needs to display some\n    // color (without having fetched the proper color). During this time the color block\n    // internal values are set to 0xff (which has a fixed color of light grey).\n    //\n    // Thus in FLI mode, one recommended solution is to \"blank\" out the first three columns\n    // with the background color on the left side of the screen. The right side is fine\n    // but it too can be blanked to have a most balanced and centered picture display.\n    fliBug: boolean = true;\n    fliBugCbColor: number = 8; // orange\n    fliBugChoiceColor: number = 15; // light grey\n    blankLeftScreenFliBugArea: boolean = false;\n    blankRightScreenMirrorFliBugArea: boolean = false;\n    blankFliBugColumnCount: number = 0;\n\n    // values chosen base on image\n    bgColor: number = 0;\n    auxColor: number = 0;\n    borderColor: number = 0;\n    globalValid: number[] = [];\n\n    // state machine for guessing\n    lastComputedCb: number = 0;\n\n    // TODO: choose global colors before init?\n    init() {\n        // adopt the system settings\n        this.b = VICII_Canvas_Details.prepare(this.sys.block, this.sys.block);\n        this.cb = VICII_Canvas_Details.prepare(this.sys.block, this.sys.cb);\n\n        this.useCb = this.sys.cb === undefined ? false : true;\n        this.colors = this.sys.block.colors;\n\n        // assume the background color is choosable (unless overridden)\n        this.preparePaletteChoices(this.sys.paletteChoices);\n\n        if (this.sys.fli != undefined) {\n            this.fliMode = true;\n            this.fliBug = this.sys.fli.bug;\n            this.blankLeftScreenFliBugArea = this.sys.fli.blankLeft;\n            this.blankRightScreenMirrorFliBugArea = this.sys.fli.blankRight;\n            this.blankFliBugColumnCount = this.sys.fli.blankColumns;\n        }\n\n        // find global colors\n        this.prepareGlobalColorChoices();\n\n        this.bitsPerColor = Math.floor(Math.log2(this.colors));\n        this.pixelsPerByte = Math.floor(8 / this.bitsPerColor);\n\n        // offset into the first byte of the color ram (which is after the screen data)\n        this.cbOffset = (this.width / this.b.w * this.height / this.b.h);\n        this.params = new Uint32Array(this.cbOffset + ((this.width / this.cb.w * this.height / this.cb.h) * (this.useCb ? 1 : 0)) + 1);\n\n        // console.log('blocks',this.b, this.cb, this.useCb, this.bitsPerColor, this.pixelsPerByte);\n        // console.log('palette',this.paletteChoices);\n        // console.log('colors',this.colors, this.globalValid, this.bgColor, this.auxColor, this.borderColor);\n        // console.log('choices',this.pixelPaletteChoices);\n        // console.log('picture', this.width, this.height, this.cbOffset, this.params.length);\n\n        // fill params of sub-blocks\n        for (var i = 0; i < this.params.length - 1; i++) { // -1 to not factor in the \"extra\" byte\n            this.guessParam(i);\n        }\n        // +1 extra parameter for global colors\n        this.params[this.params.length - 1] = this.bgColor | (this.auxColor << 4) | (this.borderColor << 8);\n    }\n    preparePixelPaletteChoices(): void {\n        let count : number = this.paletteChoices.colorsRange.max - this.paletteChoices.colorsRange.min + 1;\n        let ind = new Array<number>(count);\n        for(let l = 0, i = this.paletteChoices.colorsRange.min; i < this.paletteChoices.colorsRange.min + count; ++l, ++i) {\n            ind[l] = i;\n        }\n        this.pixelPaletteChoices = ind;\n    }\n    preparePaletteChoices(options?: PaletteChoices):void {\n        console.assert(this.pal.length > 0);\n        if (options === undefined) {\n            this.paletteChoices.background = false;\n            this.paletteChoices.aux = false;\n            this.paletteChoices.border = false;\n            this.paletteChoices.backgroundRange = { min: 0, max: this.pal.length-1 };\n            this.paletteChoices.auxRange = { min: 0, max: this.pal.length-1 };\n            this.paletteChoices.borderRange = { min: 0, max: this.pal.length-1 };\n            this.paletteChoices.colors = this.colors;\n            this.paletteChoices.colorsRange = { min: 0, max: this.pal.length-1 };\n\n            this.preparePixelPaletteChoices();\n            return;\n        }\n        this.paletteChoices.background = options.background === undefined ? false : options.background;\n        this.paletteChoices.aux = options.aux === undefined ? false : options.aux;\n        this.paletteChoices.border = options.aux === undefined ? false : options.border;\n\n        this.paletteChoices.backgroundRange = options.backgroundRange === undefined ? { min: 0, max: this.pal.length-1 } : options.backgroundRange;\n        this.paletteChoices.auxRange = options.auxRange === undefined ? { min: 0, max: this.pal.length-1 } : options.auxRange;\n        this.paletteChoices.borderRange = options.borderRange === undefined ? { min: 0, max: this.pal.length-1 } : options.borderRange;\n        this.paletteChoices.colorsRange = options.colorsRange === undefined ? { min: 0, max: this.pal.length-1 } : options.colorsRange;\n\n        this.paletteChoices.colors = options.colors === undefined ?\n            (this.colors - (this.paletteChoices.background?1:0) - (this.paletteChoices.aux?1:0) - (this.paletteChoices.border?1:0)) :\n            options.colors;\n        this.paletteChoices.colorsRange = { min: 0, max: this.pal.length-1 };\n        this.preparePixelPaletteChoices();\n\n        // some basic sanity checks\n        console.assert(this.pal.length > this.paletteChoices.backgroundRange.max - this.paletteChoices.backgroundRange.min);\n        console.assert(this.pal.length > this.paletteChoices.auxRange.max - this.paletteChoices.auxRange.min);\n        console.assert(this.pal.length > this.paletteChoices.borderRange.max - this.paletteChoices.borderRange.min);\n    }\n    chooseMin(available: boolean, range: PaletteRange, current?: number): number {\n        if (!available)\n            return current;\n        if (current === undefined)\n            return range.min;\n        return Math.min(current, range.min);\n    }\n    chooseMax(available: boolean, range: PaletteRange, current?: number): number {\n        if (!available)\n            return current;\n        if (current === undefined)\n            return range.max;\n        return Math.max(current, range.max);\n    }\n    prepareMinMax(background: boolean, aux: boolean, border: boolean): PaletteRange {\n        let chosenMin: number | undefined = this.chooseMin(background, this.paletteChoices.backgroundRange);\n        chosenMin = this.chooseMin(aux, this.paletteChoices.auxRange, chosenMin);\n        chosenMin = this.chooseMin(border, this.paletteChoices.borderRange, chosenMin);\n        //chosenMin = this.chooseMin(true, this.paletteChoices.colorsRange, chosenMin); // do not include pixel choices in this range\n        chosenMin = chosenMin === undefined ? 0 : chosenMin;\n\n        let chosenMax: number | undefined = this.chooseMax(background, this.paletteChoices.backgroundRange);\n        chosenMax = this.chooseMax(aux, this.paletteChoices.auxRange, chosenMax);\n        chosenMax = this.chooseMax(border, this.paletteChoices.borderRange, chosenMax);\n        //chosenMax = this.chooseMax(true, this.paletteChoices.colorsRange, chosenMax); // do not include pixel choices in this range\n        chosenMax = chosenMax === undefined ? (this.pal.length-1) : chosenMax;\n\n        return {min: chosenMin, max: chosenMax};\n    }\n    prepareGlobalColorChoices(): void {\n        let range = this.prepareMinMax(true, true, true);\n        let palSubset = this.pal.slice(range.min, range.max + 1);\n\n        // by default the choices result is ranked by color intensity\n        let choices = reducePaletteChoices(\n            this.ref,\n            palSubset,\n            palSubset.length,  // rank the entire palette subset (because restricted palettes may have to fallback)\n            1,\n            this.errfn);\n\n        // Need a ranking based on color usage, because if the color\n        // is selectable by a pixel then the most prominent selectable\n        // color should be chosen (to not waste a color for intensity\n        // reasons when a color is most useful as a pixel color choice);\n        // but if the color is not selectable by the color then fallback\n        // to color intensity (based on which top N colors are the\n        // most likely to be compatible with the picture);\n        let histoRankedChoices = choices.slice(0, choices.length);\n        histoRankedChoices.sort((a,b) => b.count - a.count);\n\n        // these are the possible choices for colors\n        let ranges: { id: number, selectable: boolean, range: PaletteRange }[] = [\n            { id: 0, selectable: this.paletteChoices.background, range: this.paletteChoices.backgroundRange },\n            { id: 1, selectable: this.paletteChoices.aux, range: this.paletteChoices.auxRange },\n            { id: 2, selectable: this.paletteChoices.border, range: this.paletteChoices.borderRange }\n        ];\n\n        // sort by the follow criteria:\n        // 1. colors that can be selected by pixels have priority over those that do not\n        // 2. colors that have the most restricted palettes\n        // 3. by id (if all other choices are equal)\n        ranges.sort((a,b) =>\n            (a.selectable == b.selectable) ? \n                (((a.range.max - a.range.min) == (b.range.max - b.range.min)) ?\n                    a.id - b.id :\n                    (a.range.max - a.range.min) - (b.range.max - b.range.min)) :\n                (a.selectable ? -1 : 1));\n\n        let assignId = (choice: ColorChoice, option: { id: number, selectable: boolean, range: PaletteRange }) => {\n            let index = choice.ind + range.min; // palette might be a subset\n\n            // do not select the choice if the palette range restrictions do not allow it\n            if ((index < option.range.min) || (index > option.range.max))\n                return false;\n\n            switch (option.id) {\n                case 0: this.bgColor = index; break;\n                case 1: this.auxColor = index; break;\n                case 2: this.borderColor = index; break;\n            }\n            return true;\n        };\n\n        let findBestChoice = (searchList: ColorChoice[], altList: ColorChoice[], option: { id: number, selectable: boolean, range: PaletteRange }) => {\n            // based on the priority of the ranges, pick/assign a choice color to each\n            // option in the range, starting with the most important first (as\n            // defined by the sort order)\n            for (let c = 0; c < searchList.length; ++c) {\n                let choice = searchList[c];\n\n                // attempt to assign the choice to the color option\n                if (!assignId(choice, option))\n                    continue;   // if didn't get used, try next color\n\n                // find this color choice in the alternative array (so it can be removed)\n                let found = altList.findIndex((x) => x.ind == choice.ind);\n\n                // remove the entry from the alternatively ranked list\n                console.assert(found >= 0);\n                altList.splice(found, 1);\n\n                // prevent this choice from being used again\n                searchList.splice(c, 1);\n                break;\n            }\n        };\n\n        let firstNonSelectableColorFound = false;\n\n        // try to match a color choice with the options available\n        for (let i = 0; i < ranges.length; ++i) {\n            let option = ranges[i];\n\n            if ((!option.selectable) && (!firstNonSelectableColorFound)) {\n                // found all the required colors that can be chosen by a\n                // pixel so now re-rank the remaining color choices, putting\n                // the top N \"compatible\" based on picture histo usage at the\n                // top of the array, but sorted by intensity\n                // (where N is the number of remaining \"other\" colors to choose);\n                let topNChoices : { priority: number, choice: ColorChoice }[] = []\n                for (let c = 0; c < ranges.length - i; ++c) {\n                    if (c >= histoRankedChoices.length)\n                        continue; // make sure the colors are not exhausted\n\n                    // this color is high priority to pick\n                    let topChoice = histoRankedChoices[c];\n                    let priority = choices.findIndex((x) => x.ind == topChoice.ind);\n                    console.assert(priority >= 0);\n                    topNChoices.push({priority, choice: topChoice});\n                    // removing the choice from the list is okay because it's going to be\n                    // re-inserted at the top of the new choices list\n                    choices.splice(priority, 1);\n                }\n\n                // sort the top choices by intensity\n                topNChoices.sort((a,b) => a.priority - b.priority);\n\n                // put the top N at the front of the choices list\n                choices = (topNChoices.map((x) => x.choice)).concat(choices);\n                firstNonSelectableColorFound = true;\n            }\n\n            findBestChoice((option.selectable ? histoRankedChoices : choices), (option.selectable ? choices : histoRankedChoices), option);\n            // console.log(\"findBestChoice\", i, option, histoRankedChoices, choices);\n        }\n\n        // When in FLI mode, the FLI bug messes with the left side of the screen\n        // thus making the color choices limited. This attempts to make the\n        // error are less obvious by tweaking the background and border colors.\n        if ((this.fliMode) && ((this.fliBug) || (this.blankLeftScreenFliBugArea) || (this.blankRightScreenMirrorFliBugArea)))  {\n            if (!this.paletteChoices.background) {\n                this.bgColor = this.fliBugChoiceColor;\n                this.borderColor = this.fliBugChoiceColor;\n            } else {\n                this.borderColor = this.bgColor;\n            }\n        }\n\n        if (this.paletteChoices.background)\n            this.globalValid.push(this.bgColor);\n        if (this.paletteChoices.aux)\n            this.globalValid.push(this.auxColor);\n        if (this.paletteChoices.border)\n            this.globalValid.push(this.borderColor);\n    }\n    getValidColors(index: number) {\n        let [ncols, col] = this.imageIndexToImageColumnInfo(index);\n\n        let [performBug, blank, leftBlank, rightBlank, bugCol] = this.isImageIndexInFliBugBlankingArea(index);\n        if (blank)\n            return [this.bgColor];\n\n        let p = this.imageIndexToParamOffset(index);\n        let c1 = this.params[p] & 0xf;\n        let c2 = (this.params[p] >> 4) & 0xf;\n        let c3 = (this.params[p] >> 8) & 0xf;\n\n        if (performBug) {\n            // the choices are terrible in the \"bug\" fli area\n            c1 = c2 = this.fliBugChoiceColor;\n            c3 = this.fliBugCbColor;\n        }\n\n        let valid: number[] = this.globalValid.slice(0, this.globalValid.length);\n        valid.push(c1, c2, c3);\n        valid = valid.slice(0, this.globalValid.length + this.paletteChoices.colors);\n        return valid;\n    }\n    guessParam(pUnknown: number) {\n        // do not let the caller compute the parameters for anything other that the\n        // bitmap area, as the other parameters are for the color block or the extra data\n        // as these values are computed as a result of processing the bitmap data\n        if (pUnknown >= this.cbOffset)\n            return;\n\n        return this.actualGuessParam(pUnknown);\n    }\n    actualGuessParam(pUnknown: number) {\n        console.assert(pUnknown < this.params.length - 1);\n\n        // does color block ram exist (presumption true is that it does/must exist, false to disable)\n        const calculateCb = this.useCb && (this.iterateCount < MAX_ITERATE_COUNT / 2);\n\n        let isCalculatingCb = (pUnknown >= this.cbOffset);\n        if ((isCalculatingCb) && (!calculateCb))\n            return;\n\n        let index = this.paramOrCbParamOffsetToImageIndex(pUnknown);\n\n        let cbp = (isCalculatingCb ? pUnknown : this.imageIndexToCbParamOffset(index));\n        let p = (isCalculatingCb ? this.imageIndexToParamOffset(index) : pUnknown);\n\n        if (!isCalculatingCb) {\n            // Whenever the color block color changes the surrounding pixels that also\n            // could reference that color block should be forced to NOT choose the same\n            // color as this color is always available in the color block, and choosing\n            // this same color in the color block would be wasted. As param colors are\n            // \"guessed\" in the order of the array, this ensures the color block is\n            // always calculated BEFORE the pixel colors\n            //\n            // Extra logic filters out to only calculate for the first row of any color\n            // block area, and only calculate the color block is the current color block\n            // is different than the last computed color block.\n            if (calculateCb && (this.isImageIndexFirstRowOfColorBlock(index)) && (this.lastComputedCb != cbp)) {\n                this.actualGuessParam(cbp);\n            }\n        } else {\n            this.lastComputedCb = cbp;\n        }\n\n        let [performBug, blank, leftBlank, rightBlank, bugCol] = this.isImageIndexInFliBugBlankingArea(index);\n\n        console.assert((isCalculatingCb) || (p == pUnknown));\n        console.assert((!isCalculatingCb) || (cbp == pUnknown));\n\n        let useB = isCalculatingCb ? this.cb : this.b;\n\n        // rank all colors within the size of the block (and bordering values)\n        let histo = new Uint32Array(16);\n\n        // going to scan a pixel area that is the pixel (sub)block in size\n        // +/- pixels bleeding left/right and above/below\n        let [xStart, yStart] = this.paramOrCbParamOffsetToXy(p);\n\n        for (let y = yStart - useB.yb; y < yStart + useB.h + useB.yb; y++) {\n            for (let x = xStart - useB.xb; x < xStart + useB.w + useB.xb; x++) {\n                this.updateHisto(histo, this.pixelPaletteChoices, x, y);\n            }\n        }\n\n        // never choose the colors that are always valid and available\n        // for every pixel (i.e. why waste the screen ram or color block\n        // ram on a color that is always available everywhere)\n        if (this.paletteChoices.background)\n            histo[this.bgColor] = 0;\n        if (this.paletteChoices.aux)\n            histo[this.auxColor] = 0;\n        if (this.paletteChoices.border)\n            histo[this.borderColor] = 0;\n\n        let cbColor: number = 0;\n\n        if ((!isCalculatingCb) && (this.useCb)) {\n            // filter out the cb chosen color as there's no point in choosing the\n            // same color option twice since it's already valid for this pixel\n            // block area (just like the background color is valid)\n            histo[this.params[cbp] & 0xf] = 0;\n            // promote this value to the lower nybble of the 2nd least significant byte\n            // as this value is needed later\n            cbColor = this.params[cbp] & 0xf;\n        }\n\n        // get best choices for sub-block\n        let choices = getChoices(histo);\n        let ind1 = choices[0] && choices[0].ind;\n        let ind2 = choices[1] && choices[1].ind;\n        let ind3 = choices[2] && choices[2].ind;\n        if (ind1 === undefined)\n            ind1 = this.bgColor;\n        if (ind2 === undefined)\n            ind2 = this.bgColor;\n        if (ind3 === undefined)\n            ind3 = this.bgColor;\n\n        if (!this.useCb) {\n            cbColor = ind3;\n        }\n\n        if (leftBlank) {\n            // force the chosen colors to all be background in the FLI bug area\n            cbColor = ind1 = ind2 = ind3 = this.bgColor;\n            if (!this.paletteChoices.background)\n                ind1 = ind2 = this.fliBugChoiceColor;\n        } else if (rightBlank) {\n            cbColor = ind1 = ind2 = ind3 = this.bgColor;\n            if (!this.paletteChoices.background)\n                ind1 = ind2 = this.fliBugChoiceColor;\n        }\n\n        if (isCalculatingCb) {\n            if (performBug) {\n                ind1 = this.fliBugCbColor;\n            }\n            this.params[cbp] = cbColor = ind1;\n            return cbColor;\n        }\n\n        if (performBug) {\n            // the choices when in the fli \"bug\" area are terrible\n            // (because the VIC is unable to fetch the real colors\n            // during a \"bad line\" event)\n            ind1 = ind2 = this.fliBugChoiceColor;\n            cbColor = this.fliBugCbColor;\n        }\n\n        // Store the chosen colors in the lower and upper nybble\n        // and put the chosen color block nybble into the low nybble of\n        // the 2nd least significant byte. Even though this routine does\n        // not use this value anywhere, the value is require on the export\n        // routine to determine when char data needs to pick the pixel\n        // index of %00 (background) %01 %10 (choice 1+2) and %11 meaning\n        // use the color block color as a choice. The export routine is\n        // unaware of the separated dedicated color block and only looks\n        // for the color choices attached with each \"normal\" pixel param.\n        return this.params[p] = (ind1 & 0xf) | ((ind2 << 4) & 0xf0) | ((cbColor << 8) & 0xf00);\n    }\n    updateHisto(histo: Uint32Array, colors: number[], x: number, y: number) {\n        let i = this.xyToImageIndex(x, y);\n\n        // get current color (or reference for 1st time)\n        let c1 = ((i === undefined) ? this.pal[this.bgColor] : this.indexed[i]);\n        histo[c1] += 100;\n        // get error color (TODO: why alt not img like 2-color kernels?)\n        let rgbcomp = ((i === undefined) ? this.pal[this.bgColor] : this.alt[i]);\n        let c2 = this.getClosest(rgbcomp, colors);\n        histo[c2] += 1 + this.noise;\n    }\n    paramOrCbParamOffsetToImageIndex(pUnknown: number): number {\n        let isCalculatingCb = (pUnknown >= this.cbOffset);\n        let useB = (isCalculatingCb ? this.cb : this.b);\n        let useP = (isCalculatingCb ? (pUnknown - this.cbOffset) : pUnknown);\n\n        var ncols = this.width / useB.w;     // number of pixels in a row\n        var col = useP % ncols;                // column for pixel in X direction\n        var row = Math.floor(useP / ncols);    // row for pixel in Y direction\n        // index is the starting offset representing the image's pixel X/Y\n        var index = (col * useB.w) + (row * this.width * useB.h);\n        console.assert(index < (this.width * this.height));\n        return index;\n    }\n\n    isImageIndexInFliBugBlankingArea(index: number): [boolean, boolean, boolean, boolean, number] {\n        let [ncols, col] = this.imageIndexToImageColumnInfo(index);\n\n        let bugLogic = (this.fliBug && ((col >= 0) && (col < this.blankFliBugColumnCount))) && (!this.blankLeftScreenFliBugArea);\n        let leftBlank = this.blankLeftScreenFliBugArea && ((col >= 0) && (col < this.blankFliBugColumnCount));\n        let rightBlank = this.blankLeftScreenFliBugArea && this.blankRightScreenMirrorFliBugArea && ((col >= (ncols - this.blankFliBugColumnCount)) && (col < ncols));\n        let blank = leftBlank || rightBlank;\n\n        return [bugLogic, blank, leftBlank, rightBlank, col];\n    }\n    imageIndexToImageColumnInfo(index: number): [number, number] {\n        let ncols = this.width / this.b.w;\n        let col = Math.floor(index / this.b.w) % ncols;\n        return [ncols, col];\n    }\n\n    paramOrCbParamOffsetToXy(pUnknown: number): [number, number] {\n        let imageIndex = this.paramOrCbParamOffsetToImageIndex(pUnknown);\n        return this.imageIndexToXY(imageIndex);\n    }\n\n    imageIndexToXY(index: number): [number, number] {\n        return [index % this.width, Math.floor(index / this.width)];\n    }\n    xyToImageIndex(x: number, y: number): number | undefined {\n        if ((x < 0) || (y < 0))\n            return undefined;\n        if ((x >= this.width) || (y >= this.height))\n            return undefined;\n        return y * this.width + x;\n    }\n    imageIndexToParamOffset(index: number): number {\n        let [ncols, col] = this.imageIndexToImageColumnInfo(index);\n        let row = Math.floor(index / (this.width * this.b.h));\n        let p = col + row * ncols;\n        console.assert(p < this.cbOffset);\n        return p;\n    }\n    imageIndexToCbParamOffset(index: number): number {\n        if (!this.useCb)\n            return this.cbOffset;\n\n        var ncols = this.width / this.cb.w;\n        var col = Math.floor(index / this.cb.w) % ncols;\n        var row = Math.floor(index / (this.width * this.cb.h));\n        var cbp = this.cbOffset + col + row * ncols;\n        console.assert(cbp >= this.cbOffset);\n        console.assert(cbp < this.params.length - 1); // -1 is for the extra byte\n        return cbp;\n    }\n    isImageIndexFirstRowOfColorBlock(index: number): boolean {\n        var ncols = this.width / this.b.w;\n        var row = Math.floor(index / (this.width * this.b.h));\n        return 0 == row % Math.floor(this.cb.h / this.b.h);\n    }\n}\n\nexport class NES_Canvas extends BasicParamDitherCanvas {\n    w = 16;\n    h = 16;\n    allColors = [0, 1, 2, 3, 4];\n    init() {\n        this.params = new Uint32Array(this.width / this.w * this.height / this.h);\n        for (var i = 0; i < this.params.length; i++) {\n            this.guessParam(i);\n        }\n    }\n    getValidColors(offset: number) {\n        var ncols = this.width / this.w;\n        var col = Math.floor(offset / this.w) % ncols;\n        var row = Math.floor(offset / (this.width * this.h));\n        var i = col + row * ncols;\n        var c1 = this.params[i];\n        // param specified which color to leave out\n        switch (c1 & 3) {\n            case 0: return [0, 2, 3, 4];\n            case 1: return [0, 1, 3, 4];\n            case 2: return [0, 1, 2, 4];\n            case 3: return [0, 1, 2, 3];\n        }\n        throw new Error(\"invalid param \" + c1);\n    }\n    guessParam(p: number) {\n        var ncols = this.width / this.w;\n        var col = p % ncols;\n        var row = Math.floor(p / ncols);\n        var offset = col * this.w + row * this.width * this.h;\n        var colors = [1, 2, 3, 4];\n        // rank all colors\n        var histo = new Uint32Array(16);\n        var b = 8; // border (TODO: param)\n        for (var y = -b; y < this.h + b; y++) {\n            var o = offset + y * this.width;\n            for (var x = -b; x < this.w + b; x++) {\n                // get current color (or reference for 1st time)\n                var c1 = this.indexed[o + x] | 0;\n                histo[c1] += 100;\n                // get error color (TODO: why ref works better?)\n                var rgbcomp = this.alt[o + x] | 0;\n                var c2 = this.getClosest(rgbcomp, colors);\n                histo[c2] += 1 + this.noise;\n            }\n        }\n        var choices = getChoices(histo);\n        // leave out last color, least frequent\n        choices.forEach((ch) => {\n            if (ch.ind >= 1 && ch.ind <= 4) this.params[p] = ch.ind - 1;\n        });\n    }\n}\n\nexport class HAM6_Canvas extends DitheringCanvas {\n    getValidColors(offset: number): number[] {\n        let arr = super.getValidColors(offset);\n        if (offset == 0) {\n            arr = arr.slice(0, 16);\n        } else {\n            let palindex = 16;\n            let prevrgb = this.img[offset - 1];\n            for (let chan = 0; chan < 3; chan++) {\n                for (let i = 0; i < 16; i++) {\n                    let rgb = prevrgb;\n                    rgb &= ~(0xff << (chan * 8));\n                    rgb |= (i << 4) << (chan * 8);\n                    this.pal[palindex++] = rgb;\n                }\n            }\n        }\n        return arr;\n    }\n}\n", "import { getChoices, getClosestRGB, getRGBADiff, getRGBAErrorPerceptual } from \"../common/color\";\nimport { DitherKernel, DithertronSettings, RGBDistanceFunction } from \"../common/types\";\nimport { range } from \"../common/util\";\n\nconst THRESHOLD_MAP_4X4 = [\n    0, 8, 2, 10,\n    12, 4, 14, 6,\n    3, 11, 1, 9,\n    15, 7, 13, 5,\n];\n\nexport class BaseDitheringCanvas {\n    sys: DithertronSettings;\n    pal: Uint32Array;\n    img: Uint32Array;\n    ref: Uint32Array;\n    alt: Uint32Array;\n    err: Float32Array; // (n*3)\n    indexed: Uint8Array;\n    width: number; // integer\n    height: number;\n    tmp: Uint8ClampedArray;\n    tmp2: Uint32Array;\n    changes: number;\n    noise: number = 0;\n    diffuse: number = 0.8;\n    ordered: number = 0.0;\n    ditherfn: DitherKernel = [];\n    errfn: RGBDistanceFunction = getRGBAErrorPerceptual;\n    iterateCount: number = 0;\n    params: Uint32Array;\n\n    constructor(img: Uint32Array, width: number, pal: Uint32Array) {\n        this.img = img;\n        for (var i = 0; i < pal.length; i++)\n            pal[i] |= 0xff000000;\n        this.pal = new Uint32Array(pal);\n        this.width = width;\n        this.height = Math.floor(img.length / width);\n        this.tmp = new Uint8ClampedArray(4);\n        this.tmp2 = new Uint32Array(this.tmp.buffer);\n        this.ref = new Uint32Array(img);\n        this.alt = new Uint32Array(this.ref);\n        this.err = new Float32Array(this.ref.length * 3);\n        this.indexed = new Uint8Array(this.ref.length);\n        this.changes = 0;\n        this.reset();\n    }\n    reset() {\n        this.img = new Uint32Array(this.ref);\n        this.alt.set(this.ref);\n        this.err.fill(0);\n        this.indexed.fill(0);\n        this.changes = 0;\n    }\n    init() {\n    }\n    update(offset: number) {\n        var errofs = offset * 3;\n        var rgbref = this.ref[offset];\n        // add cumulative error to pixel color, store into a clamped R,G, and B values (0-255) array\n        var ko = 1;\n        if (this.ordered > 0) {\n            let x = (offset % this.width) & 3;\n            let y = (offset / this.width) & 3;\n            ko = 1 + (THRESHOLD_MAP_4X4[x + y * 4] / 15 - 0.5) * this.ordered;\n        }\n        this.tmp[0] = (rgbref & 0xff) * ko + this.err[errofs];\n        this.tmp[1] = ((rgbref >> 8) & 0xff) * ko + this.err[errofs + 1];\n        this.tmp[2] = ((rgbref >> 16) & 0xff) * ko + this.err[errofs + 2];\n        // store the error-modified color\n        this.alt[offset] = this.tmp2[0];\n        // find closest palette color\n        var valid = this.getValidColors(offset);\n        var palidx = this.getClosest(this.tmp2[0], valid);\n        var rgbimg = this.pal[palidx];\n        // compute error and distribute to neighbors\n        var err = getRGBADiff(rgbref, rgbimg);\n        for (var i = 0; i < 3; i++) {\n            var k = (this.err[errofs + i] + err[i]) * this.diffuse;\n            // TODO: don't wrap off right edge?\n            this.ditherfn.forEach((df) => {\n                this.err[errofs + i + (df[0] + df[1] * this.width) * 3] += k * df[2];\n            });\n            this.err[errofs + i] = 0; // reset this pixel's error\n        }\n        // set new pixel rgb\n        if (this.indexed[offset] != palidx) {\n            this.indexed[offset] = palidx;\n            this.changes++;\n        }\n        this.img[offset] = rgbimg;\n        //this.img[offset] = this.tmp2[0] | 0xff000000;\n    }\n    getClosest(rgb: number, inds: number[]) {\n        return getClosestRGB(rgb, inds, this.pal, this.errfn);\n    }\n    iterate() {\n        this.changes = 0;\n        for (var i = 0; i < this.img.length; i++) {\n            this.update(i);\n        }\n        this.commit();\n        this.iterateCount++;\n    }\n    commit() {\n        //\n    }\n    getValidColors(offset: number): number[] {\n        return range(0, this.pal.length);\n    }\n}\n\nexport abstract class ParamDitherCanvas extends BaseDitheringCanvas {\n    params: Uint32Array = new Uint32Array(0);\n\n    abstract guessParam(paramIndex: number): void;\n\n    abstract init();\n\n    commit() {\n        for (var i = 0; i < this.params.length; i++) {\n            this.guessParam(i);\n        }\n    }\n}\n\nexport abstract class BasicParamDitherCanvas extends ParamDitherCanvas {\n    abstract w: number;\n    abstract h: number;\n\n    init() {\n        this.params = new Uint32Array(this.width * this.height / this.w);\n        for (var i = 0; i < this.params.length; i++) {\n            this.guessParam(i);\n        }\n    }\n}\n\n// TODO: both colors affected by bright bit\nexport abstract class TwoColor_Canvas extends BasicParamDitherCanvas {\n    ncols: number = 0;\n    nrows: number = 0;\n    border: number = 0;\n    allColors: number[] | null = null;\n\n    init() {\n        if (!this.allColors) this.allColors = range(0, this.pal.length);\n        this.indexed.fill(this.allColors[0]);\n        this.ncols = this.width / this.w;\n        this.nrows = this.height / this.h;\n        this.params = new Uint32Array(this.ncols * this.nrows);\n        for (var i = 0; i < this.params.length; i++) {\n            this.guessParam(i);\n        }\n    }\n    getValidColors(offset: number) {\n        var col = Math.floor(offset / this.w) % this.ncols;\n        var row = Math.floor(offset / (this.width * this.h));\n        var i = col + row * this.ncols;\n        var c1 = this.params[i] & 0xff;\n        var c2 = (this.params[i] >> 8) & 0xff;\n        return [c1, c2];\n    }\n    guessParam(p: number) {\n        var col = p % this.ncols;\n        var row = Math.floor(p / this.ncols);\n        var offset = col * this.w + row * (this.width * this.h);\n        var colors = this.allColors!;\n        var histo = new Uint32Array(256);\n        // pixel overlap in 8x8 window\n        var b = this.border; // border\n        for (var y = -b; y < this.h + b; y++) {\n            var o = offset + y * this.width;\n            for (var x = -b; x < this.w + b; x++) {\n                var c1 = this.indexed[o + x] | 0;\n                histo[c1] += 100;\n                var c2 = this.getClosest(this.alt[o + x] | 0, colors);\n                histo[c2] += 1 + this.noise;\n            }\n        }\n        var choices = getChoices(histo);\n        this.updateParams(p, choices);\n    }\n    updateParams(p: number, choices: { ind: number }[]) {\n        var ind1 = choices[0].ind;\n        var ind2 = choices[1] ? choices[1].ind : ind1;\n        if (ind1 > ind2) {\n            var tmp = ind1;\n            ind1 = ind2;\n            ind2 = tmp;\n        }\n        this.params[p] = ind1 + (ind2 << 8);\n    }\n}\n\nexport abstract class OneColor_Canvas extends TwoColor_Canvas {\n    bgColor: number = 0;\n\n    init() {\n        /*\n        var choices = reducePaletteChoices(this.ref, this.pal, 2, 1, this.errfn);\n        this.bgColor = choices[choices.length-1].ind;\n        this.allColors = [1,2,3,4,5,6,7].filter(x => x != this.bgColor);\n        console.log(this.bgColor, this.allColors);\n        */\n        this.bgColor = 0;\n        super.init();\n    }\n    getValidColors(offset: number) {\n        return [this.bgColor, super.getValidColors(offset)[0]];\n    }\n    updateParams(p: number, choices: { ind: number }[]) {\n        for (let c of choices) {\n            if (c.ind != this.bgColor) {\n                this.params[p] = c.ind;\n                break;\n            }\n        }\n    }\n}", "\nimport { ERROR_FUNCTIONS, getRGBAErrorPerceptual, reducePalette } from '../common/color';\nimport { DithertronSettings, PixelsAvailableMessage } from '../common/types';\nimport * as canvas from './canvas';\n\n/*\nconst emglobal : any = this['window'] || (this as any)['global'] || this;\nconst ENVIRONMENT_IS_WEB = typeof window === 'object';\nconst ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';\n*/\n\n//\n\nexport const MAX_ITERATE_COUNT = 100;\n\nexport interface DithertronInterface {\n    iterate(): void;\n}\n\nexport class Dithertron implements DithertronInterface {\n    sysparams: DithertronSettings | null = null;\n    dithcanv: canvas.DitheringCanvas | null = null;\n    sourceImageData: Uint32Array | null = null;\n    pixelsAvailable: ((msg: PixelsAvailableMessage) => void) | null = null;\n    timer: any;\n\n    setSettings(sys: DithertronSettings) {\n        this.sysparams = sys;\n        this.reset();\n    }\n    setSourceImage(imageData: Uint32Array) {\n        this.sourceImageData = imageData;\n        this.reset();\n    }\n    iterate(): boolean {\n        if (this.dithcanv == null) {\n            var sys = this.sysparams;\n            if (!sys) throw new Error(\"no sysparams\");\n            if (!this.sourceImageData) throw new Error(\"no sourceImageData\");\n            var pal = new Uint32Array(sys.pal);\n            var errfn = (ERROR_FUNCTIONS as any)[sys.errfn || 'perceptual'] || getRGBAErrorPerceptual;\n            if (sys.reduce) {\n                pal = reducePalette(this.sourceImageData, pal,\n                    sys.reduce, sys.paletteDiversity || 0, errfn);\n            }\n            if (sys.extraColors) {\n                let pal2 = new Uint32Array(pal.length + sys.extraColors);\n                pal2.set(pal);\n                pal = pal2;\n            }\n            var convFunction = canvas[sys.conv];\n            if (!convFunction) throw new Error(\"no convFunction for \" + sys.conv);\n            this.dithcanv = new convFunction(this.sourceImageData, sys.width, pal);\n            if (!this.dithcanv) throw new Error(\"no convFunction() for \" + sys.conv);\n            this.dithcanv.sys = sys;\n            this.dithcanv.errfn = errfn;\n            this.dithcanv.noise = sys.noise ? (1 << sys.noise) : 0;\n            this.dithcanv.diffuse = (sys.diffuse || 0) + 0;\n            this.dithcanv.ordered = (sys.ordered || 0) + 0;\n            this.dithcanv.ditherfn = sys.ditherfn || [];\n            this.dithcanv.init();\n        }\n        this.dithcanv.iterate();\n        this.dithcanv.noise >>= 1; // divide by 2\n        var final = this.dithcanv.changes == 0 || this.dithcanv.iterateCount > MAX_ITERATE_COUNT;\n        if (this.pixelsAvailable != null) {\n            this.pixelsAvailable({\n                img: this.dithcanv.img,\n                width: this.dithcanv.width,\n                height: this.dithcanv.height,\n                pal: this.dithcanv.pal,\n                indexed: this.dithcanv.indexed,\n                params: this.dithcanv.params,\n                final: final,\n            });\n        }\n        return !final;\n    }\n    iterateIfNeeded() {\n        if (this.iterate()) {\n            //console.log(this.dithcanv.noise, this.dithcanv.changes, this.dithcanv.iterateCount);\n        } else {\n            this.stop();\n            console.log('stop', this.dithcanv?.iterateCount);\n        }\n    }\n    reset() {\n        this.dithcanv = null;\n        this.start();\n    }\n    stop() {\n        clearTimeout(this.timer);\n        this.timer = undefined;\n    }\n    start() {\n        if (this.sysparams == null) return;\n        if (this.sourceImageData == null) return;\n        if (this.timer == null) {\n            const msec = 50;\n            var fn = () => {\n                this.timer = setTimeout(fn, msec);\n                this.iterateIfNeeded();\n            }\n            this.timer = setTimeout(fn, msec);\n        }\n    }\n}\n\n", "import { Dithertron } from \"../dither/dithertron\";\nimport { PixelsAvailableMessage } from \"../common/types\";\n\n//declare function postMessage(msg:any):void;\n\nvar worker_dtron = new Dithertron();\n\nonmessage = function (e) {\n    if (e && e.data) {\n        console.log(e.data.cmd);\n        switch (e.data.cmd) {\n            case 'reset': return worker_dtron.reset();\n            case 'setSettings': return worker_dtron.setSettings(e.data.data);\n            case 'setSourceImage': return worker_dtron.setSourceImage(e.data.data);\n        }\n    }\n}\n\nworker_dtron.pixelsAvailable = (msg: PixelsAvailableMessage) => {\n    postMessage(msg);\n};\n"],
  "mappings": "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",
  "names": ["VICII_Canvas_Details", "range"]
}
