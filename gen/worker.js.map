{
  "version": 3,
  "sources": ["../src/common/util.ts", "../src/common/color.ts", "../src/settings/palettes.ts", "../src/settings/systems.ts", "../src/dither/canvas.ts", "../src/dither/basecanvas.ts", "../src/dither/dithertron.ts", "../src/worker/worker.ts"],
  "sourcesContent": ["\nexport function hex(v: number, nd?: number) {\n    if (!nd) nd = 2;\n    return toradix(v, nd, 16);\n}\n\nexport function toradix(v: number, nd: number, radix: number) {\n    try {\n        var s = v.toString(radix).toUpperCase();\n        while (s.length < nd)\n            s = \"0\" + s;\n        return s;\n    } catch (e) {\n        return v + \"\";\n    }\n}\n\nexport function sqr(x: number) { return x * x; }\n\nexport function range(start: number, end: number): number[] {\n    let result: number[] = new Array<number>(end - start);\n    for (let i = start; i < end; i++) { result[i - start] = i; }\n    return result;\n}\n\nexport function stringToByteArray(s: string): Uint8Array {\n    var a = new Uint8Array(s.length);\n    for (var i = 0; i < s.length; i++)\n        a[i] = s.charCodeAt(i);\n    return a;\n}\n\nexport type Only<T, U> = {\n    [P in keyof T]: T[P];\n  } & {\n    [P in keyof U]?: never;\n  };\n  \nexport type Either<T, U> = Only<T, U> | Only<U, T>;\n\nexport type static_assert<T extends true> = never;\n\nexport function runtime_assert(condition: boolean, message?: any): void {\n    // test condition outside of a lock (tests use extremely slow global lock)\n    if (condition)\n        return;\n\n    if (message == undefined)\n        console.assert(condition);\n    else\n        console.assert(condition, message);\n}\n", "import { RGBDistanceFunction } from \"./types\";\nimport { range, sqr } from \"./util\";\n\nexport interface ColorChoice {\n    ind: number;\n    count: number;\n}\n\nexport class Centroid {\n    r: number = 0;\n    g: number = 0;\n    b: number = 0;\n    n: number = 0;\n    add(rgb: number) {\n        this.r += (rgb >> 0) & 0xff;\n        this.g += (rgb >> 8) & 0xff;\n        this.b += (rgb >> 16) & 0xff;\n        this.n++;\n    }\n    getAvgRGB(k: number) {\n        var r = Math.max(0, Math.min(255, this.r * k / this.n));\n        var g = Math.max(0, Math.min(255, this.g * k / this.n));\n        var b = Math.max(0, Math.min(255, this.b * k / this.n));\n        return (r << 0) | (g << 8) | (b << 16);\n    }\n}\n\nexport function reducePaletteChoices(\n    imageData: Uint32Array, \n    colors: Uint32Array, \n    count: number, \n    diversity: number,\n    distfn: RGBDistanceFunction) : ColorChoice[] \n{\n    var histo = new Int32Array(colors.length);\n    var err = new Int32Array(4);\n    var tmp = new Uint8ClampedArray(4);\n    var tmp2 = new Uint32Array(tmp.buffer);\n    var bias = diversity*0.5 + 0.5;\n    let decay = diversity*0.25 + 0.65;\n    // choose initial centroids from palette\n    var centroids : Centroid[] = [];\n    var inds : number[] = [];\n    for (let i=0; i<count; i++) {\n        inds.push(Math.floor(i * (colors.length-1) / count));\n        centroids.push(new Centroid());\n    }\n    // iterate over the frame a max. number of items\n    for (let iter=0; iter<10; iter++) {\n        // iterate over pixels, skipping some for performance\n        for (let i=iter; i<imageData.length; i+=(i&15)+1) {\n            let rgbref = imageData[i];\n            err[0] += rgbref & 0xff;\n            err[1] += (rgbref >> 8) & 0xff;\n            err[2] += (rgbref >> 16) & 0xff;\n            tmp[0] = err[0];\n            tmp[1] = err[1];\n            tmp[2] = err[2];\n            let ind1 = getClosestRGB(tmp2[0], inds, colors, distfn);\n            let alt = colors[ind1];\n            centroids[inds.indexOf(ind1)].add(tmp2[0]);\n            let score = distfn(tmp2[0], alt);\n            histo[ind1] += Math.max(0, 256 - score);\n            err[0] -= (alt & 0xff);\n            err[1] -= ((alt >> 8) & 0xff);\n            err[2] -= ((alt >> 16) & 0xff);\n            err[0] *= decay;\n            err[1] *= decay;\n            err[2] *= decay;\n        }\n        // move colors if the new one is better\n        var allinds = range(0, colors.length);\n        var nchanged = 0;\n        for (let i=0; i<count; i++) {\n            // find closest palette color to centroid mean\n            let cent = centroids[i];\n            let current = colors[inds[i]];\n            let ind2 = getClosestRGB(cent.getAvgRGB(bias), allinds, colors, distfn);\n            let better = colors[ind2];\n            // if it's different, update the color\n            if (better != current) {\n                inds[i] = ind2;\n                nchanged++;\n                //console.log(iter, i, inds[i], ind2, score);\n            }\n            // don't use this color again\n            for (let j=0; j<colors.length; j++) {\n                if (colors[j] == better) { allinds[j] = -1; }\n            }\n        }\n        if (nchanged == 0) break;\n    }\n    // sort resulting colors by intensity\n    var result = inds.map((ind) => { return {ind, count:histo[ind]} });\n    result.sort((a,b) => intensity(colors[a.ind]) - intensity(colors[b.ind]));\n    return result;\n}\n\nexport function reducePalette(\n    imageData: Uint32Array,\n    colors: Uint32Array,\n    count: number,\n    diversity: number,\n    distfn : RGBDistanceFunction) : Uint32Array \n{\n    if (colors.length == count) return new Uint32Array(colors);\n    var choices = reducePaletteChoices(imageData, colors, count, diversity, distfn);\n    console.log('reducePalette', colors.length, 'to', choices.length);\n    return new Uint32Array(choices.map((x) => colors[x.ind]));\n}\n\n//\n\nexport function getRGBADiff(rgbref: number, rgbimg: number) {\n    var err = [0,0,0];\n    for (var i=0; i<3; i++) {\n        var d = (rgbref & 0xff) - (rgbimg & 0xff);\n        err[i] = d;\n        rgbref >>= 8;\n        rgbimg >>= 8;\n    }\n    return err;\n}\n\nexport function getRGBAErrorAbsolute(rgbref: number, rgbimg: number) {\n    var mag = 0;\n    for (var i=0; i<3; i++) {\n        var d = (rgbref & 0xff) - (rgbimg & 0xff);\n        mag += sqr(d);\n        rgbref >>= 8;\n        rgbimg >>= 8;\n    }\n    return Math.sqrt(mag);\n}\n\n// TODO???\nexport function getRGBAErrorHue(rgbref: number, rgbimg: number) {\n    var r1 = ((rgbref>>0) & 0xff);\n    var g1 = ((rgbref>>8) & 0xff);\n    var b1 = ((rgbref>>16) & 0xff);\n    var r2 = ((rgbimg>>0) & 0xff);\n    var g2 = ((rgbimg>>8) & 0xff);\n    var b2 = ((rgbimg>>16) & 0xff);\n    var b = 256;\n    var avg1 = (r1+g1+b1)/3 + b;\n    var avg2 = (r2+g2+b2)/3 + b;\n    r1 /= avg1;\n    g1 /= avg1;\n    b1 /= avg1;\n    r2 /= avg2;\n    g2 /= avg2;\n    b2 /= avg2;\n    //var mag2 = Math.sqrt(sqr(r1-r2)*9 + sqr(g1-g2)*25 + sqr(b1-b2)*4);\n    //var mag2 = Math.sqrt(sqr(r1-r2)*3 + sqr(g1-g2)*5 + sqr(b1-b2)*3);\n    var mag2 = Math.sqrt(sqr(r1-r2) + sqr(g1-g2) + sqr(b1-b2))*256;\n    return mag2;\n}\n\nexport function getRGBAErrorPerceptual(rgbref: number, rgbimg: number) {\n    var r1 = ((rgbref>>0) & 0xff);\n    var g1 = ((rgbref>>8) & 0xff);\n    var b1 = ((rgbref>>16) & 0xff);\n    var r2 = ((rgbimg>>0) & 0xff);\n    var g2 = ((rgbimg>>8) & 0xff);\n    var b2 = ((rgbimg>>16) & 0xff);\n    var rmean = (r1 + r2) / 2;\n    var r = r1 - r2;\n    var g = g1 - g2;\n    var b = b1 - b2;\n    return Math.sqrt((((512+rmean)*r*r)/256) + 4*g*g + (((767-rmean)*b*b)/256));\n}\n\nexport function getRGBAErrorMax(rgbref: number, rgbimg: number) {\n    var r1 = ((rgbref>>0) & 0xff);\n    var g1 = ((rgbref>>8) & 0xff);\n    var b1 = ((rgbref>>16) & 0xff);\n    var r2 = ((rgbimg>>0) & 0xff);\n    var g2 = ((rgbimg>>8) & 0xff);\n    var b2 = ((rgbimg>>16) & 0xff);\n    return Math.max(Math.abs(r1-r2), Math.abs(g1-g2), Math.abs(b1-b2));\n}\n\nexport function intensity(rgb: number) {\n    return getRGBAErrorPerceptual(0, rgb);\n}\n\nexport const ERROR_FUNCTIONS = {\n    'perceptual': getRGBAErrorPerceptual,\n    'hue': getRGBAErrorHue,\n    'dist': getRGBAErrorAbsolute,\n    'max': getRGBAErrorMax,\n}\n\nexport function getRGBAErrorArr(a: number, b: number) {\n    var err = [0,0,0];\n    for (var i=0; i<3; i++) {\n        err[i] = ((a & 0xff) - (b & 0xff));\n        a >>= 8;\n        b >>= 8;\n    }\n    return err;\n}\n\nexport function getClosestRGB(rgb:number, inds:number[], pal:Uint32Array, distfn:RGBDistanceFunction) {\n    var best = 9999999;\n    var bestidx = -1;\n    for (var i=0; i<inds.length; i++) {\n        let ind = inds[i];\n        if (ind >= 0) {\n            var col = pal[inds[i]];\n            var score = distfn(rgb, col);\n            if (score < best) {\n                best = score;\n                bestidx = inds[i];\n            }\n        }\n    }\n    return bestidx;\n}\n\nexport function scoreRGBDistances(rgb:number, inds:number[], pal:Uint32Array, distfn:RGBDistanceFunction) {\n    let scores = [];\n    for (let i=0; i<inds.length; i++) {\n        var col = pal[inds[i]];\n        var score = distfn(rgb, col);\n        scores[i] = {i, ind:inds[i], rgb, col, score};\n    }\n    return scores;\n}\n\n//\n\nexport function getHistogram(inds: number[]) {\n    var histo = new Uint32Array(256);\n    inds.forEach((x) => histo[x]++);\n    return getChoices(histo);\n}\n\nexport function getChoices(histo: Uint32Array) {\n    var choices : {count:number,ind:number}[] = [];\n    for (var i=0; i<histo.length; i++) {\n        if (histo[i] > 0) {\n            choices.push({count:histo[i], ind:i});\n        }\n    }\n    choices.sort((a,b) => b.count - a.count);\n    return choices;\n}\n\nexport function rgb2tuple(arr: number[]) {\n    return arr.map((x) => [(x>>0) & 0xff, (x>>8) & 0xff, (x>>16) & 0xff]);\n}\n\nexport function convertToSystemPalette(pal: Uint32Array, syspal: Uint32Array | number[]) {\n    return pal.map((rgba) => syspal.indexOf(rgba & 0xffffff));\n}\n\n", "// PALETTES\n\nexport function RGB(r: number, g: number, b: number) {\n    return ((r & 0xff) << 0) | ((g & 0xff) << 8) | ((b & 0xff) << 16);\n}\n\nexport const MONO_RGB = [\n    RGB(0, 0, 0),\n    RGB(255, 255, 255)\n];\n\nexport const CMYK_RGB = [\n    RGB(0, 0, 0),\n    RGB(255, 128, 64),\n    RGB(64, 255, 128),\n    RGB(128, 64, 255),\n    RGB(255, 255, 255)\n];\n\nexport const VIC_NTSC_RGB = [\n    0x000000,\n    0xFFFFFF,\n    RGB(163, 64, 69),\n    RGB(125, 235, 228),\n    RGB(174, 70, 186),\n    RGB(94, 202, 84),\n    RGB(60, 57, 200),\n    RGB(255, 255, 111),\n    RGB(174, 96, 47),\n    RGB(110, 73, 0),\n    RGB(232, 122, 128),\n    RGB(92, 92, 92),\n    RGB(143, 143, 143),\n    RGB(179, 255, 167),\n    RGB(129, 126, 255),\n    RGB(199, 199, 199)\n];\n\n// https://www.pepto.de/projects/colorvic/\nexport const VIC_PAL_RGB = [\n    RGB(0x00, 0x00, 0x00),\n    RGB(0xff, 0xff, 0xff),\n    RGB(0x81, 0x33, 0x38),\n    RGB(0x75, 0xce, 0xc8),\n    RGB(0x8e, 0x3c, 0x97),\n    RGB(0x56, 0xac, 0x4d),\n    RGB(0x2e, 0x2c, 0x9b),\n    RGB(0xed, 0xf1, 0x71),\n    RGB(0x8e, 0x50, 0x29),\n    RGB(0x55, 0x38, 0x00),\n    RGB(0xc4, 0x6c, 0x71),\n    RGB(0x4a, 0x4a, 0x4a),\n    RGB(0x7b, 0x7b, 0x7b),\n    RGB(0xa9, 0xff, 0x9f),\n    RGB(0x70, 0x6d, 0xeb),\n    RGB(0xb2, 0xb2, 0xb2)\n];\n\n// https://en.wikipedia.org/wiki/List_of_8-bit_computer_hardware_graphics#VIC-20\nexport const VIC20_PAL_RGB = [\n    RGB(0x00,0x00,0x00),\n    RGB(0xff,0xff,0xff),\n    RGB(0x78,0x29,0x22),\n    RGB(0x87,0xd6,0xdd),\n    RGB(0xaa,0x5f,0xb6),\n    RGB(0x55,0xa0,0x49),\n    RGB(0x40,0x31,0x8d),\n    RGB(0xbf,0xce,0x72),\n    RGB(0xaa,0x74,0x49),\n    RGB(0xea,0xb4,0x89),\n    RGB(0xb8,0x69,0x62),\n    RGB(0xc7,0xff,0xff),\n    RGB(0xea,0x9f,0xf6),\n    RGB(0x94,0xe0,0x89),\n    RGB(0x80,0x71,0xcc),\n    RGB(0xff,0xff,0xb2)\n];\n\nexport const TMS9918_RGB = [\n    RGB(0, 0, 0),\n    RGB(0, 0, 0),\n    RGB(33, 200, 66),\n    RGB(94, 220, 120),\n    RGB(84, 85, 237),\n    RGB(125, 118, 252),\n    RGB(212, 82, 77),\n    RGB(66, 235, 245),\n    RGB(252, 85, 84),\n    RGB(255, 121, 120),\n    RGB(212, 193, 84),\n    RGB(230, 206, 128),\n    RGB(33, 176, 59),\n    RGB(201, 91, 186),\n    RGB(204, 204, 204),\n    RGB(255, 255, 255)\n];\n\nexport const NES_RGB = [\n    0x525252, 0xB40000, 0xA00000, 0xB1003D, 0x740069, 0x00005B, 0x00005F, 0x001840, 0x002F10, 0x084A08, 0x006700, 0x124200, 0x6D2800, 0x000000, 0x000000, 0x000000,\n    0xC4D5E7, 0xFF4000, 0xDC0E22, 0xFF476B, 0xD7009F, 0x680AD7, 0x0019BC, 0x0054B1, 0x006A5B, 0x008C03, 0x00AB00, 0x2C8800, 0xA47200, 0x000000, 0x000000, 0x000000,\n    0xF8F8F8, 0xFFAB3C, 0xFF7981, 0xFF5BC5, 0xFF48F2, 0xDF49FF, 0x476DFF, 0x00B4F7, 0x00E0FF, 0x00E375, 0x03F42B, 0x78B82E, 0xE5E218, 0x787878, 0x000000, 0x000000,\n    0xFFFFFF, 0xFFF2BE, 0xF8B8B8, 0xF8B8D8, 0xFFB6FF, 0xFFC3FF, 0xC7D1FF, 0x9ADAFF, 0x88EDF8, 0x83FFDD, 0xB8F8B8, 0xF5F8AC, 0xFFFFB0, 0xF8D8F8, 0x000000, 0x000000\n];\n\nexport const AP2HIRES_RGB = [\n    RGB(0, 0, 0),\n    RGB(255, 68, 253),\n    RGB(20, 245, 60),\n    RGB(20, 207, 253),\n    RGB(255, 106, 60),\n    RGB(255, 255, 255)\n];\n\nexport const AP2LORES_RGB = [\n    RGB(0, 0, 0),\n    RGB(227, 30, 96),\n    RGB(96, 78, 189),\n    RGB(255, 68, 253),\n    RGB(0, 163, 96),\n    RGB(156, 156, 156),\n    RGB(20, 207, 253),\n    RGB(208, 195, 255),\n    RGB(96, 114, 3),\n    RGB(255, 106, 60),\n    RGB(156, 156, 156),\n    RGB(255, 160, 208),\n    RGB(20, 245, 60),\n    RGB(208, 221, 141),\n    RGB(114, 255, 208),\n    RGB(255, 255, 255)\n];\n\nexport const ASTROCADE_RGB = [0, 2368548, 4737096, 7171437, 9539985, 11974326, 14342874, 16777215, 12255269, 14680137, 16716142, 16725394, 16734903, 16744155, 16753663, 16762879, 11534409, 13959277, 16318866, 16721334, 16730842, 16740095, 16749311, 16758783, 10420330, 12779662, 15138995, 16718039, 16727291, 16736767, 16745983, 16755199, 8847495, 11206827, 13631696, 15994612, 16724735, 16733951, 16743423, 16752639, 6946975, 9306307, 11731175, 14092287, 16461055, 16732415, 16741631, 16751103, 4784304, 7143637, 9568505, 11929087, 14297599, 16731647, 16741119, 16750335, 2425019, 4784352, 7209215, 9570047, 12004095, 14372863, 16741375, 16750847, 191, 2359523, 4718847, 7146495, 9515263, 11949311, 14318079, 16752127, 187, 224, 2294015, 4658431, 7092735, 9461247, 11895551, 14264063, 176, 213, 249, 2367999, 4736511, 7105279, 9539327, 11908095, 159, 195, 3303, 209151, 2577919, 4946431, 7380735, 9749247, 135, 171, 7888, 17140, 681983, 3050495, 5484543, 7853311, 106, 3470, 12723, 22231, 31483, 1548031, 3916799, 6285311, 73, 8557, 17810, 27318, 36570, 373759, 2742271, 5176575, 4389, 13641, 23150, 32402, 41911, 51163, 2026495, 4456447, 9472, 18724, 27976, 37485, 46737, 56246, 1834970, 4194303, 14080, 23296, 32803, 42055, 51564, 60816, 2031541, 4456409, 18176, 27648, 36864, 46116, 55624, 392556, 2752401, 5177269, 21760, 30976, 40192, 49667, 58919, 1572683, 3932016, 6291348, 24320, 33536, 43008, 52224, 716810, 3079982, 5504851, 7864183, 25856, 35328, 44544, 250368, 2619136, 4980503, 7405371, 9764703, 26624, 35840, 45312, 2413824, 4782336, 7143173, 9568041, 11927374, 26112, 35584, 2338560, 4707328, 7141376, 9502464, 11927326, 14286659, 24832, 2393344, 4762112, 7196160, 9564928, 11992832, 14352155, 16711487, 2447360, 4815872, 7250176, 9618688, 12052992, 14417664, 16776990, 16777027, 4803328, 7172096, 9606144, 11974912, 14343424, 16776965, 16777001, 16777038, 6962176, 9330688, 11764992, 14133504, 16502272, 16773655, 16777019, 16777055, 8858112, 11226880, 13660928, 16029440, 16759818, 16769070, 16777043, 16777079, 10426112, 12794624, 15163392, 16745475, 16754727, 16764235, 16773488, 16777108, 11534848, 13969152, 16337664, 16740388, 16749640, 16759148, 16768401, 16777141, 12255232, 14684928, 16725795, 16735047, 16744556, 16753808, 16763317, 16772569];\n\nexport const VCS_RGB = [\n    0x000000, 0x000000, 0x404040, 0x404040, 0x6c6c6c, 0x6c6c6c, 0x909090, 0x909090, 0xb0b0b0, 0xb0b0b0, 0xc8c8c8, 0xc8c8c8, 0xdcdcdc, 0xdcdcdc, 0xf4f4f4, 0xf4f4f4,\n    0x004444, 0x004444, 0x106464, 0x106464, 0x248484, 0x248484, 0x34a0a0, 0x34a0a0, 0x40b8b8, 0x40b8b8, 0x50d0d0, 0x50d0d0, 0x5ce8e8, 0x5ce8e8, 0x68fcfc, 0x68fcfc,\n    0x002870, 0x002870, 0x144484, 0x144484, 0x285c98, 0x285c98, 0x3c78ac, 0x3c78ac, 0x4c8cbc, 0x4c8cbc, 0x5ca0cc, 0x5ca0cc, 0x68b4dc, 0x68b4dc, 0x78c8ec, 0x78c8ec,\n    0x001884, 0x001884, 0x183498, 0x183498, 0x3050ac, 0x3050ac, 0x4868c0, 0x4868c0, 0x5c80d0, 0x5c80d0, 0x7094e0, 0x7094e0, 0x80a8ec, 0x80a8ec, 0x94bcfc, 0x94bcfc,\n    0x000088, 0x000088, 0x20209c, 0x20209c, 0x3c3cb0, 0x3c3cb0, 0x5858c0, 0x5858c0, 0x7070d0, 0x7070d0, 0x8888e0, 0x8888e0, 0xa0a0ec, 0xa0a0ec, 0xb4b4fc, 0xb4b4fc,\n    0x5c0078, 0x5c0078, 0x74208c, 0x74208c, 0x883ca0, 0x883ca0, 0x9c58b0, 0x9c58b0, 0xb070c0, 0xb070c0, 0xc084d0, 0xc084d0, 0xd09cdc, 0xd09cdc, 0xe0b0ec, 0xe0b0ec,\n    0x780048, 0x780048, 0x902060, 0x902060, 0xa43c78, 0xa43c78, 0xb8588c, 0xb8588c, 0xcc70a0, 0xcc70a0, 0xdc84b4, 0xdc84b4, 0xec9cc4, 0xec9cc4, 0xfcb0d4, 0xfcb0d4,\n    0x840014, 0x840014, 0x982030, 0x982030, 0xac3c4c, 0xac3c4c, 0xc05868, 0xc05868, 0xd0707c, 0xd0707c, 0xe08894, 0xe08894, 0xeca0a8, 0xeca0a8, 0xfcb4bc, 0xfcb4bc,\n    0x880000, 0x880000, 0x9c201c, 0x9c201c, 0xb04038, 0xb04038, 0xc05c50, 0xc05c50, 0xd07468, 0xd07468, 0xe08c7c, 0xe08c7c, 0xeca490, 0xeca490, 0xfcb8a4, 0xfcb8a4,\n    0x7c1800, 0x7c1800, 0x90381c, 0x90381c, 0xa85438, 0xa85438, 0xbc7050, 0xbc7050, 0xcc8868, 0xcc8868, 0xdc9c7c, 0xdc9c7c, 0xecb490, 0xecb490, 0xfcc8a4, 0xfcc8a4,\n    0x5c2c00, 0x5c2c00, 0x784c1c, 0x784c1c, 0x906838, 0x906838, 0xac8450, 0xac8450, 0xc09c68, 0xc09c68, 0xd4b47c, 0xd4b47c, 0xe8cc90, 0xe8cc90, 0xfce0a4, 0xfce0a4,\n    0x2c3c00, 0x2c3c00, 0x485c1c, 0x485c1c, 0x647c38, 0x647c38, 0x809c50, 0x809c50, 0x94b468, 0x94b468, 0xacd07c, 0xacd07c, 0xc0e490, 0xc0e490, 0xd4fca4, 0xd4fca4,\n    0x003c00, 0x003c00, 0x205c20, 0x205c20, 0x407c40, 0x407c40, 0x5c9c5c, 0x5c9c5c, 0x74b474, 0x74b474, 0x8cd08c, 0x8cd08c, 0xa4e4a4, 0xa4e4a4, 0xb8fcb8, 0xb8fcb8,\n    0x003814, 0x003814, 0x1c5c34, 0x1c5c34, 0x387c50, 0x387c50, 0x50986c, 0x50986c, 0x68b484, 0x68b484, 0x7ccc9c, 0x7ccc9c, 0x90e4b4, 0x90e4b4, 0xa4fcc8, 0xa4fcc8,\n    0x00302c, 0x00302c, 0x1c504c, 0x1c504c, 0x347068, 0x347068, 0x4c8c84, 0x4c8c84, 0x64a89c, 0x64a89c, 0x78c0b4, 0x78c0b4, 0x88d4cc, 0x88d4cc, 0x9cece0, 0x9cece0,\n    0x002844, 0x002844, 0x184864, 0x184864, 0x306884, 0x306884, 0x4484a0, 0x4484a0, 0x589cb8, 0x589cb8, 0x6cb4d0, 0x6cb4d0, 0x7ccce8, 0x7ccce8, 0x8ce0fc, 0x8ce0fc\n];\n\nexport const CGA_RGB = [\n    0x000000, 0xAA0000, 0x00AA00, 0xAAAA00, 0x0000AA, 0xAA00AA, 0x0055AA, 0xAAAAAA,\n    0x555555, 0xFF5555, 0x55FF55, 0xFFFF55, 0x5555FF, 0xFF55FF, 0x55FFFF, 0xFFFFFF,\n];\n\nexport const CGA_RGB_1 = [0x000000, 0x00AA00, 0x0000AA, 0x0055AA];\nexport const CGA_RGB_2 = [0x000000, 0xAAAA00, 0xAA00AA, 0xAAAAAA];\nexport const CGA_RGB_3 = [0x000000, 0xAAAA00, 0x0000AA, 0xAAAAAA];\nexport const CGA_RGB_1H = [0x000000, 0x55FF55, 0x5555FF, 0x55FFFF];\nexport const CGA_RGB_2H = [0x000000, 0xFFFF55, 0xFF55FF, 0xFFFFFF];\nexport const CGA_RGB_3H = [0x000000, 0xFFFF00, 0x5555FF, 0xFFFFFF];\nexport const SMS_RGB = generateRGBPalette(2, 2, 2);\nexport const WILLIAMS_RGB = generateRGBPalette(3, 3, 2);\nexport const ATARIST_RGB = generateRGBPalette(3, 3, 3);\nexport const TELETEXT_RGB = generateRGBPalette(1, 1, 1);\n\nexport const ZXSPECTRUM_RGB = [ // GRB\n    RGB(0x00, 0x00, 0x00),  // 0x00 Black            // dark palette\n    RGB(0x01, 0x00, 0xCE),  // 0x01 Blue\n    RGB(0xCF, 0x01, 0x00),  // 0x02 Red\n    RGB(0xCF, 0x01, 0xCE),  // 0x03 Magenta\n    RGB(0x00, 0xCF, 0x15),  // 0x04 Green\n    RGB(0x01, 0xCF, 0xCF),  // 0x05 Cyan\n    RGB(0xCF, 0xCF, 0x15),  // 0x06 Yellow\n    RGB(0xCF, 0xCF, 0xCF),  // 0x07 White\n\n    RGB(0x00, 0x00, 0x00),  // 0x08 \"Bright\" Black   // bright palette\n    RGB(0x02, 0x00, 0xFD),  // 0x09 Bright Blue\n    RGB(0xFF, 0x02, 0x01),  // 0x0A Bright Red\n    RGB(0xFF, 0x02, 0xFD),  // 0x0B Bright Magenta\n    RGB(0x00, 0xFF, 0x1C),  // 0x0C Bright Green\n    RGB(0x02, 0xFF, 0xFF),  // 0x0D Bright Cyan\n    RGB(0xFF, 0xFF, 0x1D),  // 0x0E Bright Yellow\n    RGB(0xFF, 0xFF, 0xFF),  // 0x0F Bright White\n];\n\n// see https://forums.atariage.com/topic/278354-gfx-palette-flag/\nexport const INTELLIVISION_STIC_RGB = [\n    RGB(  0,  0,  0),   // Black            // primary color set\n    RGB(  0,117,255),   // Blue\n    RGB(255, 76, 57),   // Red\n    RGB(209,185, 81),   // Tan\n    RGB(  9,185,  0),   // Dark Green\n    RGB( 48,223, 16),   // Green\n    RGB(255,229,  1),   // Yellow\n    RGB(255,255,255),   // White\n    RGB(140,140,140),   // Gray             // pastel color set\n    RGB( 40,229,192),   // Cyan\n    RGB(255,160, 46),   // Orange\n    RGB(100,103,  0),   // Brown\n    RGB(255, 41,255),   // Pink\n    RGB(140,143,255),   // Light Blue\n    RGB(124,237,  0),   // Yellow Green\n    RGB(196, 43,252),   // Purple\n];\n\nexport const AMSTRAD_CPC_RGB = [\n    0x000000, 0x800090, 0xFF0000,\n    0x000080, 0x800080, 0xFF0080,\n    0x0000FF, 0x8000FF, 0xFF00FF,\n    0x008000, 0x808000, 0xFF8000,\n    0x008080, 0x808080, 0xFF8080,\n    0x0080FF, 0x8080FF, 0xFF80FF,\n    0x00FF00, 0x80FF00, 0xFFFF00,\n    0x00FF80, 0x80FF80, 0xFFFF80,\n    0x00FFFF, 0x80FFFF, 0xFFFFFF,\n];\n\n// TODO: should these be reversed?\nexport const PICO8_RGB = [\n    0x000000, //0, 0, 0 black\n    0x1D2B53, //29, 43, 83 dark-blue\n    0x7E2553, //126, 37, 83 dark-purple\n    0x008751, //0, 135, 81 dark-green\n    0xAB5236, //171, 82, 54 brown\n    0x5F574F, //95, 87, 79 dark-gray\n    0xC2C3C7, //194, 195, 199 light-gray\n    0xFFF1E8, //255, 241, 232 white\n    0xFF004D, //255, 0, 77 red\n    0xFFA300, //255, 163, 0 orange\n    0xFFEC27, //255, 236, 39 yellow\n    0x00E436, //0, 228, 54 green\n    0x29ADFF, //41, 173, 255 blue\n    0x83769C, //131, 118, 156 indigo\n    0xFF77A8, //255, 119, 168 pink\n    0xFFCCAA, //255, 204, 170 peach\n];\n\nexport const TIC80_RGB = [\n    0x140C1C,\n    0x442434,\n    0x30346D,\n    0x4E4A4F,\n    0x854C30,\n    0x346524,\n    0xD04648,\n    0x757161,\n    0x597DCE,\n    0xD27D2C,\n    0x8595A1,\n    0x6DAA2C,\n    0xD2AA99,\n    0x6DC2CA,\n    0xDAD45E,\n    0xDEEED6,\n];\n\n// TODO: https://geeks-world.github.io/articles/467811/index.html\nexport const CHANNELF_RGB = [\n    // background\n    /*\n    0xe0e0e0,\n    0x101010,\n    0x91ffa6,\n    0xced0ff,\n    */\n    // foreground\n    0xfcfcfc,\n    0xff3153,\n    0x02cc5d,\n    0x4b3ff3,\n];\n\nexport const GAMEBOY_GREEN_RGB = [\n    0x0f380f,\n    0x306230,\n    0x0fac8c,\n    0x0fccac,\n];\n\nexport const GAMEBOY_MONO_RGB = [\n    0x000000,\n    0x555555,\n    0xaaaaaa,\n    0xffffff,\n];\n\nexport const RGB_444 = generateRGBPalette(4, 4, 4);\nexport const GAMEBOY_COLOR_RGB = RGB_444;\nexport const AMIGA_OCS_COLOR_RGB = RGB_444;\nexport const IIGS_COLOR_RGB = RGB_444;\nexport const GAMEGEAR_COLOR_RGB = RGB_444;\nexport const SNES_B5G5R5_RGB = generateSNESB5G5R5();\nexport const SNES_BBPGGGPRRRP = generateSNESDirectColor();\n\nexport const MC6847_PALETTE0 = [\n    RGB(0x30, 0xd2, 0x00),    /* NTSC: RGB( 28, 213,  16), */   // green \n    RGB(0xf5, 0xf5, 0x80),    /* NTSC: RGB(226, 219,  15), */   // yellow\n    RGB(0x4c, 0x3a, 0xb4),    /* NTSC: RGB(  3,  32, 255), */   // blue  \n    RGB(0x9a, 0x32, 0x36),    /* NTSC: RGB(226,  32,  10), */   // red   \n];\n\nexport const MC6847_PALETTE1 = [\n    RGB(0xd8, 0xd8, 0xd8),    /* NTSC: RGB( 205, 219, 224), */  // buff    \n    RGB(0x41, 0xaf, 0x71),    /* NTSC: RGB(  22, 208, 226), */  // cyan    \n    RGB(0xd8, 0x6e, 0xf0),    /* NTSC: RGB( 203,  57, 226), */  // magenta \n    RGB(0xd4, 0x7f, 0x00),    /* NTSC: RGB( 204,  45,  16), */  // orange  \n];\n\nfunction generateRGBPalette(rr: number, gg: number, bb: number) {\n    var n = 1 << (rr + gg + bb);\n    var rs = 255 / ((1 << rr) - 1);\n    var gs = 255 / ((1 << gg) - 1);\n    var bs = 255 / ((1 << bb) - 1);\n    var pal = new Uint32Array(n);\n    for (var i = 0; i < n; i++) {\n        var r = (i & ((1 << rr) - 1));\n        var g = ((i >> rr) & ((1 << gg) - 1));\n        var b = ((i >> (rr + gg)) & ((1 << bb) - 1));\n        pal[i] = RGB(r * rs, g * gs, b * bs);\n    }\n    return pal;\n}\n\nfunction generateSNESB5G5R5() : Uint32Array {\n    let result = new Uint32Array(1 << (5+5+5));\n    let i = 0;\n    for (let r = 0; r < (1 << 5); ++r) {\n        for (let g = 0; g < (1 << 5); ++g) {\n            for (let b = 0; b < (1 << 5); ++b, ++i) {\n                let color = (r << 3) | (g << (3 + 8)) | (b << (3 + 16));\n                color |= ((r & 0b11100) >> 2) | (((g & 0b11100) >> 2) << 8) | (((b & 0b11100) >> 2) << 16);\n                result[i] = color;\n            }\n        }\n    }\n    return result;\n}\n\nfunction generateSNESDirectColor() : Uint32Array {\n\n    let result = new Uint32Array(1 << (4+4+3));\n    let i = 0;\n    for (let r = 0; r < (1 << 4); ++r) {\n        for (let g = 0; g < (1 << 4); ++g) {\n            for (let b = 0; b < (1 << 3); ++b, ++i) {\n                let color = (r << 4) | (g << (4 + 8)) | (b << (5 + 16));\n                result[i] = color;\n            }\n        }\n    }\n    return result;\n}\n", "import { DithertronSettings } from \"../common/types\";\nimport * as palettes from \"./palettes\";\n\nexport const SYSTEMS: (DithertronSettings | null)[] = [\n    {\n        id: 'c64.multi',\n        name: 'C-64 Multi',\n        width: 160,\n        height: 200,\n        scaleX: 0.936 * 2,\n        conv: 'VICII_Canvas',\n        pal: palettes.VIC_PAL_RGB,\n        block: { w:4, h:8, colors: 4, xb:1, yb:2 },\n        cell: {w: 4, h: 8, msbToLsb: true },\n        paletteChoices:{background: true},        \n        cb: { w: 4, h: 8, xb: 1, yb: 2 },\n        param: { extra: 1 },\n        toNative: 'exportC64Multi',\n    },\n    {\n        id: 'c64.multi.fli',\n        name: 'C-64 Multi FLI (w/o bug)',\n        width: 160,\n        height: 200,\n        scaleX: 0.936 * 2,\n        conv: 'VICII_Canvas',\n        pal: palettes.VIC_PAL_RGB,\n        block: { w: 4, h: 1, colors: 4, xb: 1 },\n        paletteChoices:{ background: true },\n        cell: {w: 4, h: 8, msbToLsb: true },\n        cb: { w: 4, h: 8, xb: 1, yb: 2 },\n        param: { extra: 1 },\n        fli: { bug: false, blankLeft: false, blankRight: false, blankColumns: 3 },\n        toNative: 'exportC64Multi',\n    },\n    {\n        id: 'c64.multi.fli.bug',\n        name: 'C-64 Multi FLI (with bug)',\n        width: 160,\n        height: 200,\n        scaleX: 0.936 * 2,\n        conv: 'VICII_Canvas',\n        pal: palettes.VIC_PAL_RGB,\n        block: { w: 4, h: 1, colors: 4, xb: 1 },\n        cell: {w: 4, h: 8, msbToLsb: true },\n        paletteChoices: { background: true },\n        cb: { w: 4, h: 8, xb: 1, yb: 2 },\n        param: { extra: 1 },\n        fli: { bug: true, blankLeft: false, blankRight: false, blankColumns: 3 },\n        toNative: 'exportC64Multi',\n    },\n    {\n        id: 'c64.multi.fli.blank.left',\n        name: 'C-64 Multi FLI (Left blank)',\n        width: 160,\n        height: 200,\n        scaleX: 0.936 * 2,\n        conv: 'VICII_Canvas',\n        pal: palettes.VIC_PAL_RGB,\n        block: { w: 4, h: 1, colors: 4, xb: 1 },\n        cell: {w: 4, h: 8, msbToLsb: true },\n        paletteChoices: { background: true },\n        cb: { w: 4, h: 8, xb: 1, yb: 2 },\n        param: { extra: 1 },\n        fli: { bug: false, blankLeft: true, blankRight: false, blankColumns: 3 },\n        toNative: 'exportC64Multi',\n    },\n    {\n        id: 'c64.multi.fli.blank',\n        name: 'C-64 Multi FLI (L/R blank)',\n        width: 160,\n        height: 200,\n        scaleX: 0.936 * 2,\n        conv: 'VICII_Canvas',\n        pal: palettes.VIC_PAL_RGB,\n        block: { w: 4, h: 1, colors: 4, xb: 1 },\n        cell: {w: 4, h: 8, msbToLsb: true },\n        paletteChoices: { background:true },\n        cb: { w: 4, h: 8, xb: 1, yb: 2 },\n        param: { extra: 1 },\n        fli: { bug: false, blankLeft: true, blankRight: true, blankColumns: 3 },\n        toNative: 'exportC64Multi',\n    },\n    {\n        id: 'c64.hires',\n        name: 'C-64 Hires',\n        width: 320,\n        height: 200,\n        scaleX: 0.936,\n        conv: 'VICII_Canvas',\n        pal: palettes.VIC_PAL_RGB,\n        block: { w: 8, h: 8, colors: 2 },\n        cell: {w: 8, h: 8, msbToLsb: true },\n        param: { extra: 1 },\n        toNative: 'exportC64Hires',\n    },\n    {\n        id: 'c64.hires.fli',\n        name: 'C-64 Hires FLI (w/o bug)',\n        width: 320,\n        height: 200,\n        scaleX: 0.936,\n        conv: 'VICII_Canvas',\n        pal: palettes.VIC_PAL_RGB,\n        block: { w: 8, h: 1, colors: 2 },\n        cell: {w: 8, h: 8, msbToLsb: true },\n        param: { extra: 1 },\n        fli: { bug: false, blankLeft: false, blankRight: false, blankColumns: 3 },\n        toNative: 'exportC64Hires',\n    },\n    {\n        id: 'c64.hires.fli.bug',\n        name: 'C-64 Hires FLI (with bug)',\n        width: 320,\n        height: 200,\n        scaleX: 0.936,\n        conv: 'VICII_Canvas',\n        pal: palettes.VIC_PAL_RGB,\n        block: { w: 8, h: 1, colors: 2 },\n        cell: {w: 8, h: 8, msbToLsb: true },\n        param: { extra: 1 },\n        fli: { bug: true, blankLeft: false, blankRight: false, blankColumns: 3 },\n        toNative: 'exportC64Hires',\n    },\n    {\n        id: 'c64.hires.fli.blank',\n        name: 'C-64 Hires FLI (L/R blank)',\n        width: 320,\n        height: 200,\n        scaleX: 0.936,\n        conv: 'VICII_Canvas',\n        pal: palettes.VIC_PAL_RGB,\n        block: { w: 8, h: 1, colors: 2 },\n        cell: {w: 8, h: 8, msbToLsb: true },\n        param: { extra: 1 },\n        fli: { bug: false, blankLeft: true, blankRight: true, blankColumns: 3 },\n        toNative: 'exportC64Hires',\n    },\n    {\n        id: 'nes',\n        name: 'NES (4 color, 240 tiles)',\n        width: 160,\n        height: 96,\n        scaleX: 8 / 7,\n        conv: 'DitheringCanvas',\n        pal: palettes.NES_RGB,\n        reduce: 4,\n        toNative: 'exportNES',\n    },\n    {\n        id: 'msx',\n        name: 'MSX/Coleco (TMS9918A)',\n        width: 256,\n        height: 192,\n        conv: 'Msx_Canvas',\n        pal: palettes.TMS9918_RGB,\n        block: { w: 8, h: 1, colors: 2 },\n        cell: {w: 8, h: 8, msbToLsb: true },\n        toNative: 'exportTMS9918',\n    },\n    {\n        id: 'apple2.hires',\n        name: 'Apple ][ (Hires)',\n        width: 140,\n        height: 192,\n        scaleX: 2,\n        conv: 'Apple2_Canvas',\n        pal: palettes.AP2HIRES_RGB,\n        block: { w: 7, h: 1, colors: 4 },\n        toNative: 'exportApple2HiresToHGR',\n    },\n    {\n        id: 'atari8.d',\n        name: 'Atari ANTIC (Mode D)',\n        width: 160,\n        height: 96,\n        scaleX: 0.8571,\n        conv: 'DitheringCanvas',\n        pal: palettes.VCS_RGB,\n        reduce: 4,\n        toNative: 'exportFrameBuffer',\n        exportFormat: { bpp: 2, brev: true },\n    },\n    {\n        id: 'atari8.f.10',\n        name: 'Atari ANTIC (Mode F/10)',\n        width: 80,\n        height: 192,\n        scaleX: 0.8571 * 4,\n        conv: 'DitheringCanvas',\n        pal: palettes.VCS_RGB,\n        reduce: 9,\n        toNative: 'exportFrameBuffer',\n        exportFormat: { bpp: 4, brev: true },\n    },\n    {\n        id: 'vcs',\n        name: 'Atari VCS',\n        width: 40,\n        height: 192,\n        scaleX: 6,\n        conv: 'DitheringCanvas',\n        pal: palettes.VCS_RGB,\n        reduce: 2,\n        toNative: 'exportVCSPlayfield',\n    },\n    {\n        id: 'vcs.color',\n        name: 'Atari VCS (Color)',\n        width: 40,\n        height: 192,\n        scaleX: 6,\n        conv: 'VCSColorPlayfield_Canvas',\n        pal: palettes.VCS_RGB,\n        toNative: 'exportVCSPlayfield',\n    },\n    {\n        id: 'astrocade',\n        name: 'Bally Astrocade',\n        width: 160,\n        height: 98,\n        scaleX: 1,\n        conv: 'DitheringCanvas',\n        pal: palettes.ASTROCADE_RGB,\n        reduce: 4,\n        toNative: 'exportFrameBuffer',\n        exportFormat: { bpp: 2, brev: true },\n    },\n    {\n        id: 'zx',\n        name: 'ZX Spectrum',\n        width: 256,\n        height: 192,\n        conv: 'ZXSpectrum_Canvas',\n        pal: palettes.ZXSPECTRUM_RGB,\n        block: { w: 8, h: 8, colors: 2 },\n        cell: { w: 8, h: 8, msbToLsb: true },\n        toNative: 'exportZXSpectrum'\n    },\n    {\n        id: 'zx.dark',\n        name: 'ZX Spectrum (dark only)',\n        width: 256,\n        height: 192,\n        conv: 'ZXSpectrum_Canvas',\n        pal: palettes.ZXSPECTRUM_RGB,\n        block: { w: 8, h: 8, colors: 2 },\n        cell: { w: 8, h: 8, msbToLsb: true },\n        paletteChoices: { colorsRange: { min: 0, max: 7 } },\n        toNative: 'exportZXSpectrum'\n    },\n    {\n        id: 'zx.bright',\n        name: 'ZX Spectrum (bright only)',\n        width: 256,\n        height: 192,\n        conv: 'ZXSpectrum_Canvas',\n        pal: palettes.ZXSPECTRUM_RGB,\n        block: { w: 8, h: 8, colors: 2 },\n        cell: { w: 8, h: 8, msbToLsb: true },\n        paletteChoices: { colorsRange: { min: 8, max: 15 } },\n        toNative: 'exportZXSpectrum'\n    },\n    {\n        id: 'zx.dark.bright',\n        name: 'ZX Spectrum (dark made bright only)',\n        width: 256,\n        height: 192,\n        conv: 'ZXSpectrum_Canvas',\n        pal: palettes.ZXSPECTRUM_RGB,\n        block: { w: 8, h: 8, colors: 2 },\n        cell: { w: 8, h: 8, msbToLsb: true },\n        paletteChoices: { colorsRange: { min: 0, max: 7 } }, // aux is used to signal the special mode\n        customize: { flipPalette: true },\n        toNative: 'exportZXSpectrum'\n    },\n    {\n        id: 'zx.bright.dark',\n        name: 'ZX Spectrum (bright made dark only)',\n        width: 256,\n        height: 192,\n        conv: 'ZXSpectrum_Canvas',\n        pal: palettes.ZXSPECTRUM_RGB,\n        block: { w: 8, h: 8, colors: 2 },\n        cell: { w: 8, h: 8, msbToLsb: true },\n        paletteChoices: { colorsRange: { min: 8, max: 15 } }, // aux is used to signal the special mode\n        customize: { flipPalette: true },\n        toNative: 'exportZXSpectrum'\n    },\n    {\n        id: 'cpc.mode0',\n        name: 'Amstrad CPC (mode 0)',\n        width: 160,\n        height: 200,\n        scaleX: 2,\n        conv: 'DitheringCanvas',\n        pal: palettes.AMSTRAD_CPC_RGB,\n        reduce: 16,\n        toNative: 'exportFrameBuffer',\n        exportFormat: { bpp: 4, yremap: [3, 80, 2048], bitremap: [7, 3, 5, 1, 6, 2, 4, 0] }\n    },\n    {\n        id: 'cpc.mode1',\n        name: 'Amstrad CPC (mode 1)',\n        width: 320,\n        height: 200,\n        scaleX: 1,\n        conv: 'DitheringCanvas',\n        pal: palettes.AMSTRAD_CPC_RGB,\n        reduce: 4,\n        toNative: 'exportFrameBuffer',\n        exportFormat: { bpp: 2, yremap: [3, 80, 2048], bitremap: [7, 3, 6, 2, 5, 1, 4, 0] }\n    },\n\n    // null == separator, systems with runnable source code are above\n    null,\n\n    {\n        id: 'vic20.hires',\n        name: 'VIC-20 Hires',\n        width: 160,\n        height: 160,\n        scaleX: 1.5,\n        conv: 'VICII_Canvas',\n        pal: palettes.VIC20_PAL_RGB,\n        block: { w: 8, h: 8, colors: 2 },               // can choose the background, or one foreground color\n        cell: {w: 8, h: 8, msbToLsb: true },\n        paletteChoices: {\n            background: true,                           // pixels can choose the background color\n            backgroundRange: { min: 0, max: 7 },        // (but with a reduced color palette)\n            colorsRange: { min: 0, max: 7 }             // pixels can only choose from a reduced color palette\n        },\n        toNative:'exportVicHires',\n    },\n    {\n        id: 'vic20.multi',\n        name: 'VIC-20 Multi',\n        width: 80,\n        height: 160,\n        scaleX: 3,\n        conv: 'VICII_Canvas',\n        pal: palettes.VIC20_PAL_RGB,\n        block: { w: 4, h: 8, colors: 4 },               // can choose background, aux, border and one foreground color\n        cell: {w: 4, h: 8, msbToLsb: true },    \n        paletteChoices: {\n            background: true,                           // pixels can choose the background color\n            backgroundRange: { min: 0, max: 15 },\n            aux: true,                                  // pixels can choose the aux color\n            auxRange: { min: 0, max: 15},\n            border: true,                               // pixels can choose the border color\n            borderRange: { min: 0, max: 7 },            // (but with a reduced palette)\n            colorsRange: { min: 0, max: 7 }             // a reduced palette applies to the pixel colors\n        },\n        toNative:'exportVicMulti',\n    },\n    {\n        id: 'nes.1bpp',\n        name: 'NES (1bpp) (8x8) (32x32) Planar',\n        width: 32*8,\n        height: 32*8,\n        scaleX: 1,\n        conv: 'SNES_Canvas',\n        pal: palettes.SNES_B5G5R5_RGB,\n        block: { w: 8, h: 8, colors: 2, msbToLsb: false },  // bit plane colors are stored LSB to MSB\n        cell: { w: 8, h: 8, msbToLsb: true },                // cell pixels are stored MSB to LSB\n        paletteChoices: {\n            backgroundRange: { min: 0, max: 1 },\n            auxRange: { min: 0, max: 1 },\n            borderRange: { min: 0, max: 1 },\n            colorsRange: { min: 0, max: 1 }\n        },\n        reduce: 2,\n        customize: { outputTileset: false, outputPalette: true },\n        toNative:'exportSNES'\n    },\n    {\n        id: 'nes.2bpp',\n        name: 'NES (2bpp) (8x8) (32x32) Planar',\n        width: 32*8,\n        height: 32*8,\n        scaleX: 1,\n        conv: 'SNES_Canvas',\n        pal: palettes.SNES_B5G5R5_RGB,\n        block: { w: 8, h: 8, colors: 4, msbToLsb: false },\n        cell: { w: 8, h: 8, msbToLsb: true },\n        paletteChoices: {\n            backgroundRange: { min: 0, max: 3 },\n            auxRange: { min: 0, max: 3 },\n            borderRange: { min: 0, max: 3 },\n            colorsRange: { min: 0, max: 3 }\n        },\n        reduce: 4,\n        customize: { outputTileset: false, outputPalette: true },\n        toNative:'exportSNES'\n    },\n    {\n        id: 'snes.2bpp',\n        name: 'SNES (+Gameboy/GBC) (2bpp) (8x8) (32x32) Planar',\n        width: 32*8,\n        height: 32*8,\n        scaleX: 1,\n        conv: 'SNES_Canvas',\n        pal: palettes.SNES_B5G5R5_RGB,\n        block: { w: 8, h: 8, colors: 4, msbToLsb: false },\n        cell: { w: 8, h: 8, msbToLsb: true },\n        paletteChoices: {\n            backgroundRange: { min: 0, max: 3 },\n            auxRange: { min: 0, max: 3 },\n            borderRange: { min: 0, max: 3 },\n            colorsRange: { min: 0, max: 3 }\n        },\n        customize: { outputTileset: false, outputPalette: false, planeToMemory: 'interleaved' },\n        reduce: 4,\n        toNative:'exportSNES'\n    },\n    {\n        id: 'snes.3bpp',\n        name: 'SNES (3bpp) (8x8) (32x32) Planar',\n        width: 32*8,\n        height: 32*8,\n        scaleX: 1,\n        conv: 'SNES_Canvas',\n        pal: palettes.SNES_B5G5R5_RGB,\n        block: { w: 8, h: 8, colors: 8, msbToLsb: false },\n        cell: { w: 8, h: 8, msbToLsb: true },\n        paletteChoices: {\n            backgroundRange: { min: 0, max: 7 },\n            auxRange: { min: 0, max: 7 },\n            borderRange: { min: 0, max: 7 },\n            colorsRange: { min: 0, max: 7 }\n        },\n        reduce: 8,\n        customize: { planeToMemory: 'interleaved' },\n        toNative:'exportSNES'\n    },\n    {\n        id: 'snes.4bpp',\n        name: 'SNES (4bpp) (8x8) (32x32) Planar',\n        width: 32*8,\n        height: 32*8,\n        scaleX: 1,\n        conv: 'SNES_Canvas',\n        pal: palettes.SNES_B5G5R5_RGB,\n        block: { w: 8, h: 8, colors: 16, msbToLsb: false },\n        cell: { w: 8, h: 8, msbToLsb: true },\n        paletteChoices: {\n            backgroundRange: { min: 0, max: 15 },\n            auxRange: { min: 0, max: 15},\n            borderRange: { min: 0, max: 15 },\n            colorsRange: { min: 0, max: 15 }\n        },\n        customize: { planeToMemory: 'interleaved' },\n        reduce: 16,\n        toNative:'exportSNES'\n    },\n    {\n        id: 'snes.8bpp',\n        name: 'SNES (8bpp) (8x8) (32x32) Planar',\n        width: 32*8,\n        height: 32*8,\n        scaleX: 1,\n        conv: 'SNES_Canvas',\n        pal: palettes.SNES_B5G5R5_RGB,\n        block: { w: 8, h: 8, colors: 256, msbToLsb: false },\n        cell: { w: 8, h: 8, msbToLsb: true },\n        paletteChoices: {\n            backgroundRange: { min: 0, max: 255 },\n            auxRange: { min: 0, max: 255 },\n            borderRange: { min: 0, max: 255 },\n            colorsRange: { min: 0, max: 255 }\n        },\n        customize: { planeToMemory: 'interleaved' },\n        reduce: 256,\n        toNative:'exportSNES'\n    },\n    {\n        id: 'snes.mode7',\n        name: 'SNES (Mode 7) (8bpp) (8x8) (32x32)',\n        width: 32*8,\n        height: 32*8,\n        scaleX: 1,\n        conv: 'SNES_Canvas',\n        pal: palettes.SNES_B5G5R5_RGB,\n        block: { w: 8, h: 8, colors: 256, msbToLsb: false },\n        cell: { w: 8, h: 8, msbToLsb: true },\n        paletteChoices: {\n            backgroundRange: { min: 0, max: 255 },\n            auxRange: { min: 0, max: 255 },\n            borderRange: { min: 0, max: 255 },\n            colorsRange: { min: 0, max: 255 }\n        },\n        customize: { bitsInPlane: 8, planes: 1 },\n        reduce: 256,\n        toNative:'exportSNES'\n    },\n    {\n        id: 'neo.geopocket',\n        name: 'NEO Geo Pocket Color (2pp) (8x8) (32x32)',\n        width: 32*8,\n        height: 32*8,\n        scaleX: 1,\n        conv: 'SNES_Canvas',\n        pal: palettes.SNES_B5G5R5_RGB,\n        block: { w: 8, h: 8, colors: 256, msbToLsb: false },\n        cell: { w: 8, h: 8, msbToLsb: true },\n        paletteChoices: {\n            backgroundRange: { min: 0, max: 255 },\n            auxRange: { min: 0, max: 255 },\n            borderRange: { min: 0, max: 255 },\n            colorsRange: { min: 0, max: 255 }\n        },\n        customize: { outputTileset: false, outputPalette: false, bitsInPlane: 2, planes: 1, planeLittleEndian: false },\n        reduce: 256,\n        toNative:'exportSNES'\n    },\n    {\n        id: 'virtualboy',\n        name: 'Virtual Boy (2pp) (8x8) (32x32)',\n        width: 32*8,\n        height: 32*8,\n        scaleX: 1,\n        conv: 'SNES_Canvas',\n        pal: palettes.SNES_B5G5R5_RGB,\n        block: { w: 8, h: 8, colors: 4, msbToLsb: false },\n        cell: { w: 8, h: 8, msbToLsb: true },\n        paletteChoices: {\n            backgroundRange: { min: 0, max: 3 },\n            auxRange: { min: 0, max: 3 },\n            borderRange: { min: 0, max: 3 },\n            colorsRange: { min: 0, max: 3 }\n        },\n        customize: { outputTileset: false, outputPalette: false, bitsInPlane: 2, planes: 1, planeLittleEndian: true },\n        reduce: 4,\n        toNative:'exportSNES'\n    },\n    {\n        id: 'gg.4pp',\n        name: 'Game Gear (+Sega Master Systems/Wonder Color) (4bpp) (8x8) (32x32) Linear',\n        width: 32*8,\n        height: 32*8,\n        scaleX: 1,\n        conv: 'SNES_Canvas',\n        pal: palettes.SNES_B5G5R5_RGB,\n        block: { w: 8, h: 8, colors: 16, msbToLsb: false },\n        cell: { w: 8, h: 8, msbToLsb: true },\n        paletteChoices: {\n            backgroundRange: { min: 0, max: 15 },\n            auxRange: { min: 0, max: 15 },\n            borderRange: { min: 0, max: 15 },\n            colorsRange: { min: 0, max: 15 }\n        },\n        customize: { outputTileset: false, outputPalette: false, planeToMemory: 'linear' },\n        reduce: 16,\n        toNative:'exportSNES'\n    },\n    {\n        id: 'genesis',\n        name: 'Genesis/x68k (4pp) (8x8) (32x32)',\n        width: 32*8,\n        height: 32*8,\n        scaleX: 1,\n        conv: 'SNES_Canvas',\n        pal: palettes.SNES_B5G5R5_RGB,\n        block: { w: 8, h: 8, colors: 16, msbToLsb: false },\n        cell: { w: 8, h: 8, msbToLsb: true },\n        paletteChoices: {\n            backgroundRange: { min: 0, max: 15 },\n            auxRange: { min: 0, max: 15 },\n            borderRange: { min: 0, max: 15 },\n            colorsRange: { min: 0, max: 15 }\n        },\n        customize: { outputTileset: false, outputPalette: false, bitsInPlane: 4, planes: 1, planeLittleEndian: true },\n        reduce: 16,\n        toNative:'exportSNES'\n    },\n    {\n        id: 'snes.8bpp.direct',\n        name: 'SNES (8bpp) (8x8) (32x32) Direct Color',\n        width: 32*8,\n        height: 32*8,\n        scaleX: 1,\n        conv: 'SNES_Canvas_Direct',\n        pal: palettes.SNES_BBPGGGPRRRP,\n        block: { w: 8, h: 8, colors: 2048, msbToLsb: false },\n        cell: { w: 8, h: 8, msbToLsb: true },\n        paletteChoices: {\n            backgroundRange: { min: 0, max: 2047 },\n            auxRange: { min: 0, max: 2047 },\n            borderRange: { min: 0, max: 2047 },\n            colorsRange: { min: 0, max: 2047 }\n        },\n        customize: { outputTileset: true, outputPalette: false, transformColor: 'bbgggrrr', planes: 8 },\n        toNative:'exportSNES'\n    },\n    {\n        id: 'stic',\n        name: 'Intellivision STIC (GRAM/GROM) (FGBG)',\n        width: 8*8,    // actual is 20x12 but the gram only allows for 64 gram cards\n        height: 8*8,\n        conv: 'Stic_Fgbg_Canvas',\n        pal: palettes.INTELLIVISION_STIC_RGB,\n        block: { w: 8, h: 8, colors: 2 },\n        cell: { w: 8, h: 8, msbToLsb: true },\n        paletteChoices: { backgroundRange: { min: 0, max: 15 }, colorsRange: { min: 0, max: 7 } },\n        toNative: 'exportSticFgbg'\n    },\n    {\n        id: 'stic.stack.grom',\n        name: 'Intellivision STIC (GROM only) (Color Stack Mode)',\n        width: 20*8,\n        height: 12*8,\n        conv: 'Stic_ColorStack_Canvas',\n        pal: palettes.INTELLIVISION_STIC_RGB,\n        block: { w: 8, h: 8, colors: 2 },\n        cell: { w: 8, h: 8, msbToLsb: true },\n        cb: { w: 8, h: 8, xb: 0, yb: 0 },   // important to leave xb/yb as 0 (so no color bleeding happens in scoring of stack colors)\n        param: { extra: 4 },\n        paletteChoices: { colors: 1, backgroundRange: { min: 0, max: 15 }, colorsRange: { min: 0, max: 7 } },\n        toNative: 'exportSticColorStack'\n    },\n    {\n        id: 'stic.stack.gram',\n        name: 'Intellivision STIC (GRAM only) (Color Stack Mode)',\n        width: 8*8,    // actual is 20x12 but the gram only allows for 64 gram cards\n        height: 8*8,\n        conv: 'Stic_ColorStack_Canvas',\n        pal: palettes.INTELLIVISION_STIC_RGB,\n        block: { w: 8, h: 8, colors: 2 },\n        cell: { w: 8, h: 8, msbToLsb: true },\n        cb: { w: 8, h: 8 },\n        param: { extra: 4 },\n        paletteChoices: { colors: 1, backgroundRange: { min: 0, max: 15 }, colorsRange: { min: 0, max: 15 } },\n        toNative: 'exportSticColorStack'\n    },\n    {\n        id: 'stic.stack.gromram',\n        name: 'Intellivision STIC (GROM+GRAM) (Color Stack Mode)',\n        width: 20*8,\n        height: 12*8,\n        conv: 'Stic_ColorStack_Canvas',\n        pal: palettes.INTELLIVISION_STIC_RGB,\n        block: { w: 8, h: 8, colors: 2 },\n        cell: { w: 8, h: 8, msbToLsb: true, xb: 0, yb: 0 }, // important that xb/yb are 0 (so no color bleeding happens in scoring)\n        cb: { w: 8, h: 8 },\n        // the cell params will carry the array of which cells will use the gram (instead of the grom)\n        param: { cell: true, extra: 4 },\n        paletteChoices: { colors: 1, backgroundRange: { min: 0, max: 15 }, colorsRange: { min: 0, max: 7 } },\n        toNative: 'exportSticColorStack'\n    },\n    {\n        id: 'stic.stack.grom.single',\n        name: 'Intellivision STIC (GROM only) (Single BG Color Stack)',\n        width: 20*8,\n        height: 12*8,\n        conv: 'Stic_ColorStack_Canvas',\n        pal: palettes.INTELLIVISION_STIC_RGB,\n        block: { w: 8, h: 8, colors: 2 },\n        cell: { w: 8, h: 8, msbToLsb: true },\n        cb: { w: 8, h: 8, xb: 0, yb: 0 },   // important to leave xb/yb as 0 (so no color bleeding happens in scoring of stack colors)\n        param: { extra: 4 },\n        paletteChoices: { colors: 1, backgroundRange: { min: 0, max: 15 }, colorsRange: { min: 0, max: 7 } },\n        customize: { singleColor: true },\n        toNative: 'exportSticColorStack'\n    },\n    {\n        id: 'stic.stack.gram.single',\n        name: 'Intellivision STIC (GRAM only) (Single BG Color Stack)',\n        width: 8*8,    // actual is 20x12 but the gram only allows for 64 gram cards\n        height: 8*8,\n        conv: 'Stic_ColorStack_Canvas',\n        pal: palettes.INTELLIVISION_STIC_RGB,\n        block: { w: 8, h: 8, colors: 2 },\n        cell: { w: 8, h: 8, msbToLsb: true },\n        cb: { w: 8, h: 8 },\n        param: { extra: 4 },\n        paletteChoices: { colors: 1, backgroundRange: { min: 0, max: 15 }, colorsRange: { min: 0, max: 15 } },\n        customize: { singleColor: true },\n        toNative: 'exportSticColorStack'\n    },    \n    {\n        id: 'stic.stack.gromram.single',\n        name: 'Intellivision STIC (GROM+GRAM) (Single BG Color Stack)',\n        width: 20*8,\n        height: 12*8,\n        conv: 'Stic_ColorStack_Canvas',\n        pal: palettes.INTELLIVISION_STIC_RGB,\n        block: { w: 8, h: 8, colors: 2 },\n        cell: { w: 8, h: 8, msbToLsb: true, xb: 0, yb: 0 }, // important that xb/yb are 0 (so no color bleeding happens in scoring)\n        cb: { w: 8, h: 8 },\n        // the cell params will carry the array of which cells will use the gram (instead of the grom)\n        param: { cell: true, extra: 4 },\n        paletteChoices: { colors: 1, backgroundRange: { min: 0, max: 15 }, colorsRange: { min: 0, max: 7 } },\n        customize: { singleColor: true },\n        toNative: 'exportSticColorStack'\n    },\n    {\n        id: 'nes4f',\n        name: 'NES (4 color, full screen)',\n        width: 256,\n        height: 240,\n        scaleX: 8 / 7,\n        conv: 'DitheringCanvas',\n        pal: palettes.NES_RGB,\n        reduce: 4,\n        toNative: 'exportNES',\n    },\n    {\n        id: 'nes5f',\n        name: 'NES (5 color, full screen)',\n        width: 256,\n        height: 240,\n        scaleX: 8 / 7,\n        conv: 'NES_Canvas',\n        pal: palettes.NES_RGB,\n        reduce: 5,\n        toNative: 'exportNES',\n    },\n    {\n        id: 'atari7800.160a',\n        name: 'Atari 7800 (160A)',\n        width: 160,\n        height: 240,\n        scaleX: 2,\n        conv: 'DitheringCanvas',\n        pal: palettes.VCS_RGB,\n        reduce: 4,\n    },\n    {\n        id: 'atari7800.160b',\n        name: 'Atari 7800 (160B)',\n        width: 160,\n        height: 240,\n        scaleX: 2,\n        conv: 'DitheringCanvas',\n        pal: palettes.VCS_RGB,\n        reduce: 12,\n    },\n    {\n        id: 'sms',\n        name: 'Sega Master System',\n        width: 176, // only 488 unique tiles max, otherwise 256x240\n        height: 144,\n        scaleX: 8 / 7,\n        conv: 'DitheringCanvas',\n        pal: palettes.SMS_RGB,\n        reduce: 16,\n    },\n    {\n        id: 'sms-gg',\n        name: 'Sega GameGear',\n        width: 160,\n        height: 144,\n        scaleX: 1.2,\n        conv: 'DitheringCanvas',\n        pal: palettes.GAMEGEAR_COLOR_RGB,\n        reduce: 16,\n    },\n    {\n        id: 'bbcmicro.mode2',\n        name: 'BBC Micro (mode 2)',\n        width: 160,\n        height: 256,\n        scaleX: 2,\n        conv: 'DitheringCanvas',\n        pal: palettes.TELETEXT_RGB,\n    },\n    {\n        id: 'apple2.lores',\n        name: 'Apple ][ (Lores)',\n        width: 40,\n        height: 48,\n        scaleX: 1.5,\n        conv: 'DitheringCanvas',\n        pal: palettes.AP2LORES_RGB,\n        toNative: 'exportFrameBuffer',\n        exportFormat: { bpp: 4 },\n    },\n    {\n        id: 'apple2.dblhires',\n        name: 'Apple ][ (Double-Hires)',\n        width: 140,\n        height: 192,\n        scaleX: 2,\n        conv: 'DitheringCanvas',\n        pal: palettes.AP2LORES_RGB,\n    },\n    {\n        id: 'appleiigs.320.16',\n        name: 'Apple IIGS (16 colors)',\n        width: 320,\n        height: 200,\n        conv: 'DitheringCanvas',\n        pal: palettes.IIGS_COLOR_RGB,\n        reduce: 16,\n    },\n    {\n        id: 'channelf',\n        name: 'Fairchild Channel F',\n        width: 102,\n        height: 58,\n        conv: 'DitheringCanvas',\n        pal: palettes.CHANNELF_RGB,\n        reduce: 4, // TODO: https://geeks-world.github.io/articles/467811/index.html\n    },\n    {\n        id: 'mac',\n        name: 'Mac 128K',\n        width: 512,\n        height: 342,\n        conv: 'DitheringCanvas',\n        pal: palettes.MONO_RGB,\n    },\n    {\n        id: 'x86.cga.04h.1',\n        name: 'PC CGA (Mode 04h, palette 1)',\n        width: 320,\n        height: 200,\n        scaleX: 200 / 320 * 1.37,\n        conv: 'DitheringCanvas',\n        pal: palettes.CGA_RGB_1,\n        toNative: 'exportFrameBuffer',\n        exportFormat: { bpp: 1, np: 2 },\n    },\n    {\n        id: 'x86.cga.04h.1B',\n        name: 'PC CGA (Mode 04h, bright 1)',\n        width: 320,\n        height: 200,\n        scaleX: 200 / 320 * 1.37,\n        conv: 'DitheringCanvas',\n        pal: palettes.CGA_RGB_1H,\n        toNative: 'exportFrameBuffer',\n        exportFormat: { bpp: 1, np: 2 },\n    },\n    {\n        id: 'x86.cga.04h.2',\n        name: 'PC CGA (Mode 04h, palette 2)',\n        width: 320,\n        height: 200,\n        scaleX: 200 / 320 * 1.37,\n        conv: 'DitheringCanvas',\n        pal: palettes.CGA_RGB_2,\n        toNative: 'exportFrameBuffer',\n        exportFormat: { bpp: 1, np: 2 },\n    },\n    {\n        id: 'x86.cga.04h.2B',\n        name: 'PC CGA (Mode 04h, bright 2)',\n        width: 320,\n        height: 200,\n        scaleX: 200 / 320 * 1.37,\n        conv: 'DitheringCanvas',\n        pal: palettes.CGA_RGB_2H,\n        toNative: 'exportFrameBuffer',\n        exportFormat: { bpp: 1, np: 2 },\n    },\n    {\n        id: 'x86.cga.05h',\n        name: 'PC CGA (Mode 05h)',\n        width: 320,\n        height: 200,\n        scaleX: 200 / 320 * 1.37,\n        conv: 'DitheringCanvas',\n        pal: palettes.CGA_RGB_3,\n        toNative: 'exportFrameBuffer',\n        exportFormat: { bpp: 1, np: 2 },\n    },\n    {\n        id: 'x86.cga.05h.B',\n        name: 'PC CGA (Mode 05h, bright)',\n        width: 320,\n        height: 200,\n        scaleX: 200 / 320 * 1.37,\n        conv: 'DitheringCanvas',\n        pal: palettes.CGA_RGB_3H,\n        toNative: 'exportFrameBuffer',\n        exportFormat: { bpp: 1, np: 2 },\n    },\n    {\n        id: 'x86.ega.0dh',\n        name: 'PC EGA (Mode 0Dh)',\n        width: 320,\n        height: 200,\n        scaleX: 200 / 320 * 1.37,\n        conv: 'DitheringCanvas',\n        pal: palettes.CGA_RGB,\n        toNative: 'exportFrameBuffer',\n        exportFormat: { bpp: 1, np: 4 },\n    },\n    {\n        id: 'x86.ega.10h',\n        name: 'PC EGA (Mode 10h)',\n        width: 640,\n        height: 350,\n        scaleX: 350 / 640 * 1.37,\n        conv: 'DitheringCanvas',\n        pal: palettes.CGA_RGB,\n        toNative: 'exportFrameBuffer',\n        exportFormat: { bpp: 1, np: 4 },\n    },\n    {\n        id: 'williams',\n        name: 'Williams Arcade',\n        width: 304,\n        height: 256,\n        conv: 'DitheringCanvas',\n        pal: palettes.WILLIAMS_RGB,\n        reduce: 16,\n    },\n    {\n        id: 'pico8',\n        name: 'PICO-8',\n        width: 128,\n        height: 128,\n        conv: 'DitheringCanvas',\n        pal: palettes.PICO8_RGB,\n    },\n    {\n        id: 'tic80',\n        name: 'TIC-80',\n        width: 240,\n        height: 136,\n        conv: 'DitheringCanvas',\n        pal: palettes.TIC80_RGB,\n    },\n    {\n        id: 'gb',\n        name: 'Game Boy Classic',\n        width: 160,\n        height: 144,\n        scaleX: 10 / 9,\n        conv: 'DitheringCanvas',\n        pal: palettes.GAMEBOY_GREEN_RGB,\n    },\n    /*\n    {\n        id:'gbc',\n        name:'Game Boy Color',\n        width:160,\n        height:144,\n        aspect:1,\n        conv:'DitheringCanvas',\n        pal:GAMEBOY_COLOR_RGB,\n        reduce:32,\n    },\n    */\n    {\n        id: 'amiga.lores',\n        name: 'Amiga (Lores)',\n        width: 320,\n        height: 256,\n        conv: 'DitheringCanvas',\n        pal: palettes.AMIGA_OCS_COLOR_RGB,\n        reduce: 32,\n        //toNative:'exportFrameBuffer',\n        //exportFormat:{bpp:1,brev:true,np:5},\n    },\n    {\n        id: 'amiga.lores.ham6',\n        name: 'Amiga (Lores, HAM6)',\n        width: 320,\n        height: 256,\n        conv: 'HAM6_Canvas',\n        pal: palettes.AMIGA_OCS_COLOR_RGB,\n        reduce: 16,\n        extraColors: 48,\n        //toNative:'exportFrameBuffer',\n        //exportFormat:{bpp:1,brev:true,np:6},\n    },\n    {\n        id: 'cx16.lores',\n        name: 'Commander X16 (Lores)',\n        width: 320,\n        height: 240,\n        scaleX: 1,\n        conv: 'DitheringCanvas',\n        pal: palettes.AMIGA_OCS_COLOR_RGB,\n        reduce: 256\n    },\n    {\n        id: 'cx16.hires',\n        name: 'Commander X16 (Hires, cropped)',\n        width: 640,\n        height: 400,\n        scaleX: 1,\n        conv: 'DitheringCanvas',\n        pal: palettes.AMIGA_OCS_COLOR_RGB,\n        reduce: 16\n    },\n    {\n        id: 'compucolor',\n        name: 'Compucolor',\n        width: 160,\n        height: 192,\n        scaleX: 1.6,\n        conv: 'Compucolor_Canvas',\n        pal: palettes.ZXSPECTRUM_RGB,\n        block: { w: 2, h: 4, colors: 2 },\n    },\n    // https://www.bighole.nl//pub/mirror/homepage.ntlworld.com/kryten_droid/teletext/spec/teletext_spec_1974.htm\n    {\n        id: 'teletext',\n        name: 'Teletext',\n        width: 40 * 2,\n        height: 24 * 3,\n        scaleX: 4 / 3,\n        conv: 'Teletext_Canvas',\n        pal: palettes.TELETEXT_RGB,\n        block: { w: 2, h: 3, colors: 2 },\n    },\n    {\n        id: 'atarist',\n        name: 'Atari ST',\n        width: 320,\n        height: 200,\n        scaleX: 1,\n        conv: 'DitheringCanvas',\n        pal: palettes.ATARIST_RGB,\n        reduce: 16\n    },\n    {\n        id: 'MC6847.CG2.palette0',\n        name: 'MC6847 (CG2, palette 0)',\n        width: 128,\n        height: 64,\n        scaleX: 1 / 1.3,\n        conv: 'DitheringCanvas',\n        pal: palettes.MC6847_PALETTE0,\n        reduce: 4,\n        toNative: 'exportMC6847'\n    },\n    {\n        id: 'MC6847.CG2.palette1',\n        name: 'MC6847 (CG2, palette 1)',\n        width: 128,\n        height: 64,\n        scaleX: 1 / 1.3,\n        conv: 'DitheringCanvas',\n        pal: palettes.MC6847_PALETTE1,\n        reduce: 4,\n        toNative: 'exportMC6847'\n    },\n    {\n        id: 'MC6847.CG3.palette0',\n        name: 'MC6847 (CG3, palette 0)',\n        width: 128,\n        height: 96,\n        scaleX: 1 / 1.3 * 96 / 64,\n        conv: 'DitheringCanvas',\n        pal: palettes.MC6847_PALETTE0,\n        reduce: 4,\n        toNative: 'exportMC6847'\n    },\n    {\n        id: 'MC6847.CG3.palette1',\n        name: 'MC6847 (CG3, palette 1)',\n        width: 128,\n        height: 96,\n        scaleX: 1 / 1.3 * 96 / 64,\n        conv: 'DitheringCanvas',\n        pal: palettes.MC6847_PALETTE1,\n        reduce: 4,\n        toNative: 'exportMC6847'\n    },\n    {\n        id: 'MC6847.CG6.palette0',\n        name: 'MC6847 (CG6, palette 0)',\n        width: 128,\n        height: 192,\n        scaleX: 1 / 1.3 * 192 / 64,\n        conv: 'DitheringCanvas',\n        pal: palettes.MC6847_PALETTE0,\n        reduce: 4,\n        toNative: 'exportMC6847'\n    },\n    {\n        id: 'MC6847.CG6.palette1',\n        name: 'MC6847 (CG6, palette 1)',\n        width: 128,\n        height: 192,\n        scaleX: 1 / 1.3 * 192 / 64,\n        conv: 'DitheringCanvas',\n        pal: palettes.MC6847_PALETTE1,\n        reduce: 4,\n        toNative: 'exportMC6847'\n    },\n    {\n        id: 'vcs.48',\n        name: 'Atari VCS (48x48 bitmap)',\n        width: 48,\n        height: 48,\n        conv: 'DitheringCanvas',\n        pal: palettes.VCS_RGB,\n        reduce: 2,\n    },\n    {\n        id: 'pce.256x240',\n        name: 'PC Engine (256x240)',\n        width: 256,\n        height: 240,\n        scaleX: 5 / 4,\n        conv: 'DitheringCanvas',\n        pal: palettes.ATARIST_RGB,\n        reduce: 16,\n    },\n    {\n        id: 'phememo-d30.landscape',\n        name: 'Phomemo D30 (landscape)',\n        width: 288,\n        height: 88,\n        conv: 'DitheringCanvas',\n        pal: palettes.MONO_RGB,\n    },\n    {\n        id: 'phememo-d30.portrait',\n        name: 'Phomemo D30 (portrait)',\n        width: 88,\n        height: 288,\n        conv: 'DitheringCanvas',\n        pal: palettes.MONO_RGB,\n    },\n];\n\nexport var SYSTEM_LOOKUP: { [id: string]: DithertronSettings } = {};\nSYSTEMS.forEach((sys) => { if (sys) SYSTEM_LOOKUP[sys.id || sys.name] = sys; });\n\n", "import { getChoices, reducePaletteChoices, ColorChoice } from \"../common/color\";\nimport { PaletteChoices, PaletteRange  } from \"../common/types\";\nimport {\n    BaseDitheringCanvas,\n    BasicParamDitherCanvas,\n    OneColor_Canvas,\n    TwoColor_Canvas,\n    CommonBlockParamDitherCanvas,\n    AddToHistogramFromCurrentColorAtHandler,\n    ScoredColorChoice,\n} from \"./basecanvas\";\nimport { MAX_ITERATE_COUNT } from \"./dithertron\";\nimport { range, runtime_assert } from \"../common/util\";\n\nexport class DitheringCanvas extends BaseDitheringCanvas {\n    // just a wrapper for the base class so we can find it\n}\n\nexport class Teletext_Canvas extends OneColor_Canvas {\n    w = 2;\n    h = 3;\n}\nexport class VCSColorPlayfield_Canvas extends TwoColor_Canvas {\n    w = 40;\n    h = 1;\n}\nexport class Compucolor_Canvas extends TwoColor_Canvas {\n    w = 2;\n    h = 4;\n}\n\nexport class Apple2_Canvas extends TwoColor_Canvas {\n    w = 7;\n    h = 1;\n    allColors = [0, 1, 2, 3, 4, 5];\n    guessParam(p: number) {\n        var offset = p * this.w;\n        var colors = this.allColors;\n        var histo = new Uint32Array(16);\n        for (var i = 0; i < this.w; i++) {\n            var c1 = this.indexed[offset + i] | 0;\n            histo[c1] += 100;\n            var c2 = this.getClosest(this.alt[offset + i] | 0, colors);\n            histo[c2] += 1 + this.noise;\n        }\n        var hibit = histo[3] + histo[4] > histo[1] + histo[2];\n        this.params[p] = hibit ? 1 : 0;\n    }\n    getValidColors(offset: number) {\n        var i = Math.floor(offset / this.w);\n        var hibit = (this.params[i] & 1) != 0;\n        // hi bit set? (covers 2 bytes actually)\n        if (hibit)\n            return [0, 3, 4, 5];\n        else\n            return [0, 1, 2, 5];\n    }\n}\n\nexport class VICII_Canvas extends CommonBlockParamDitherCanvas {\n\n    // FLI mode causes a VIC bug to appear coined the \"fli bug\". The issue is that\n    // when $D011 is forced into a \"bad line\" condition which forces the VIC to\n    // refetch color data and the CPU stalls the VIC long enough that exactly 3 character\n    // values wide lack proper color block data (they instead use left over color block\n    // data from the previous raster line).\n    //\n    // Whenever the vertical scroll register $D011 lower 3-bits match the current\n    // raster line number's lower 3 bits, the VIC is forced to re-fetch color block data.\n    // Under normal VIC/CPU conditions this happens every 8 raster lines because the\n    // vertical scroll value has 8 possible values and thus the raster line bits match\n    // the vertical scroll bits once in every 8 raster lines.\n    //\n    // Normally the VIC detects this condition while still inside the H-blank thus no\n    // problem occurs. However, the FLI logic needs to swap the $D011 register's scroll\n    // value every single scan line and re-adjust the screen data memory address, then\n    // loop. This forces the VIC to enter a \"bad line\" state at improper timing than\n    // normal conditions and the VIC must re-fetch the color block data. Worse, the\n    // CPU timings require the VIC wait a 3-cycle handoff period prior to fetching the\n    // color block data. Thus while the VIC is waiting, it still needs to display some\n    // color (without having fetched the proper color). During this time the color block\n    // internal values are set to 0xff (which has a fixed color of light grey).\n    //\n    // Thus in FLI mode, one recommended solution is to \"blank\" out the first three columns\n    // with the background color on the left side of the screen. The right side is fine\n    // but it too can be blanked to have a most balanced and centered picture display.\n    fliBug: boolean = true;\n    fliBugCbColor: number = 8; // orange\n    fliBugChoiceColor: number = 15; // light grey\n    blankLeftScreenFliBugArea: boolean = false;\n    blankRightScreenMirrorFliBugArea: boolean = false;\n    blankFliBugColumnCount: number = 0;\n\n    override init(): void {\n        super.prepare();\n\n        if (this.fliMode) {\n            this.fliBug = this.sys.fli.bug;\n            this.blankLeftScreenFliBugArea = this.sys.fli.blankLeft;\n            this.blankRightScreenMirrorFliBugArea = this.sys.fli.blankRight;\n            this.blankFliBugColumnCount = this.sys.fli.blankColumns;\n            if (!this.paletteChoices.background) {\n                this.borderColor = this.fliBugChoiceColor;\n            }\n        }\n    }\n\n    override getValidColors(imageIndex: number): number[] {\n        let offset = this.imageIndexToBlockOffset(imageIndex);\n        let cbOffset = this.imageIndexToCbOffset(imageIndex);\n\n        let [performBug, blank, leftBlank, rightBlank, bugCol] = this.isImageIndexInFliBugBlankingArea(imageIndex);\n        if (blank) {\n            if (!this.paletteChoices.background)\n                return [this.fliBugChoiceColor];\n            return [this.backgroundColor];\n        }\n\n        let extracted = this.extractColorsFromBlockParams(offset, this.paramInfo.cb ? 2 : 3);\n        if (this.paramInfo.cb) {\n            extracted.push(...this.extractColorsFromCbParams(cbOffset, 1));\n        }\n\n        if (performBug) {\n            // the choices are terrible in the \"bug\" fli area\n            extracted[0] = extracted[1] = this.fliBugChoiceColor;\n            extracted[2] = this.fliBugCbColor;\n        }\n\n        let valid: number[] = this.globalValid.slice(0, this.globalValid.length);\n        valid.push(...extracted);\n        valid = valid.slice(0, this.globalValid.length + this.paletteChoices.colors);\n        return valid;\n    }\n    override guessBlockParam(offset: number): void {\n\n        let imageIndex = this.blockOffsetToImageIndex(offset);\n\n        let cbOffset = this.imageIndexToCbOffset(imageIndex);\n\n        let [performBug, blank, leftBlank, rightBlank, bugColumn] = this.isImageIndexInFliBugBlankingArea(imageIndex);\n\n        // never choose the colors that are always valid and available\n        // for every pixel (i.e. why waste the screen ram or color block\n        // ram on a color that is always available everywhere)\n\n        let cbColor: number = 0;\n        let pixelChoiceColors = this.pixelPaletteChoices;\n\n        if (this.paramInfo.cb) {\n            // filter out the cb chosen color as there's no point in choosing the\n            // same color option twice since it's already valid for this pixel\n            // block area (just like the background color is valid)\n            let cbExtracted = this.extractColorsFromCbParams(cbOffset, 1);\n            pixelChoiceColors = this.spliceColor(cbExtracted[0], this.pixelPaletteChoices);\n        }\n\n        // reset histogram values\n        this.histogram.fill(0);\n        this.scores.fill(0);\n\n        // rank all colors within the size of the block (and bordering values)\n        if (!this.firstCommit)\n            this.addToBlockHistogramFromCurrentColor(offset, this.histogram, pixelChoiceColors);\n        let scored = this.addToBlockHistogramFrom(offset, this.histogram, this.scores, pixelChoiceColors, this.firstCommit ? this.ref : this.alt);\n\n        if (this.paramInfo.cb) {\n            // filter out the cb chosen color as there's no point in choosing the\n            // same color option twice since it's already valid for this pixel\n            // block area (just like the background color is valid)\n            let cbExtracted = this.extractColorsFromCbParams(cbOffset, 1);\n\n            this.histogram[cbExtracted[0]] = 0;\n            // promote this value to the lower nybble of the 2nd least significant byte\n            // as this value is needed later\n            cbColor = cbExtracted[0];\n        }\n\n        // get best choices for sub-block\n        let choices = this.getScoredChoicesByCount(scored);\n        let ind1 = choices[0] && choices[0].ind;\n        let ind2 = choices[1] && choices[1].ind;\n        let ind3 = choices[2] && choices[2].ind;\n        if (ind1 === undefined)\n            ind1 = this.backgroundColor;\n        if (ind2 === undefined)\n            ind2 = this.backgroundColor;\n        if (ind3 === undefined)\n            ind3 = this.backgroundColor;\n\n        if (!this.paramInfo.cb) {\n            cbColor = ind3;\n        }\n\n        if (leftBlank) {\n            // force the chosen colors to all be background in the FLI bug area\n            cbColor = ind1 = ind2 = ind3 = this.backgroundColor;\n            if (!this.paletteChoices.background)\n                ind1 = ind2 = this.fliBugChoiceColor;\n        } else if (rightBlank) {\n            cbColor = ind1 = ind2 = ind3 = this.backgroundColor;\n            if (!this.paletteChoices.background)\n                ind1 = ind2 = this.fliBugChoiceColor;\n        }\n\n        if (performBug) {\n            // the choices when in the fli \"bug\" area are terrible\n            // (because the VIC is unable to fetch the real colors\n            // during a \"bad line\" event)\n            ind1 = ind2 = this.fliBugChoiceColor;\n            cbColor = this.fliBugCbColor;\n        }\n\n        let subsetChoices = [ ind1, ind2 ];\n        subsetChoices = subsetChoices.splice(0, this.paletteChoices.colors);\n\n        let sorted = [ ...subsetChoices.sort((a, b) => a - b), cbColor ];\n\n        // Store the chosen colors in the lower and upper nybble\n        // and put the chosen color block nybble into the low nybble of\n        // the 2nd least significant byte. Even though this routine does\n        // not use this value anywhere, the value is require on the export\n        // routine to determine when char data needs to pick the pixel\n        // index of %00 (background) %01 %10 (choice 1+2) and %11 meaning\n        // use the color block color as a choice. The export routine is\n        // unaware of the separated dedicated color block and only looks\n        // for the color choices attached with each \"normal\" pixel param.\n\n        this.updateBlockColorParam(offset, sorted);\n    }\n\n    override guessCbParam(offset: number): void {\n\n        // does color block ram exist (presumption true is that it does/must exist, false to disable)\n        if ((!this.paramInfo.cb) || (this.iterateCount > MAX_ITERATE_COUNT / 2))\n            return;\n\n        let imageIndex = this.cbOffsetToImageIndex(offset);\n\n        let [performBug, blank, leftBlank, rightBlank, bugCol] = this.isImageIndexInFliBugBlankingArea(imageIndex);\n\n        // reset histogram values\n        this.histogram.fill(0);\n        this.scores.fill(0);\n\n        // rank all colors within the size of the block (and bordering values)\n        if (!this.firstCommit)\n            this.addToCbHistogramFromCurrentColor(offset, this.histogram, this.pixelPaletteChoices);\n        let scored = this.addToCbHistogramFrom(offset, this.histogram, this.scores, this.pixelPaletteChoices, this.firstCommit ? this.ref : this.alt);\n\n        // get best choices for sub-block\n        let choices = this.getScoredChoicesByCount(scored);\n        let cbColor = choices[0] && choices[0].ind;\n\n        if (leftBlank) {\n            // force the chosen colors to all be background in the FLI bug area\n            cbColor = this.backgroundColor;\n            if (!this.paletteChoices.background)\n                cbColor = this.fliBugCbColor;\n        } else if (rightBlank) {\n            cbColor = this.backgroundColor;\n            if (!this.paletteChoices.background)\n                cbColor = this.fliBugCbColor;\n        }\n\n        if (performBug) {\n            if (!this.paletteChoices.background)\n                cbColor = this.fliBugChoiceColor;\n        }\n\n        this.updateCbColorParam(offset, [cbColor]);\n    }\n\n    isImageIndexInFliBugBlankingArea(index: number): [boolean, boolean, boolean, boolean, number] {\n        let { column } = this.imageIndexToBlockInfo(index);\n\n        let bugLogic = (this.fliBug && ((column >= 0) && (column < this.blankFliBugColumnCount))) && (!this.blankLeftScreenFliBugArea);\n        let leftBlank = this.blankLeftScreenFliBugArea && ((column >= 0) && (column < this.blankFliBugColumnCount));\n        let rightBlank = this.blankLeftScreenFliBugArea && this.blankRightScreenMirrorFliBugArea && ((column >= (this.block.columns - this.blankFliBugColumnCount)) && (column < this.block.columns));\n        let blank = leftBlank || rightBlank;\n\n        return [bugLogic, blank, leftBlank, rightBlank, column];\n    }\n\n}\n\n// TODO: figure out why light+dark oscillates between two states and doesn't converge\nexport class ZXSpectrum_Canvas extends CommonBlockParamDitherCanvas {\n    darkColors: number[];\n    brightColors: number[];\n    flipPalette: boolean;\n\n    paletteRange: PaletteRange;\n\n    histogram = new Uint32Array(this.pal.length);   // temporary scratch histogram buffer\n    scores = new Uint32Array(this.pal.length);      // temporary scratch scores buffer\n\n    override init(): void {\n        super.prepare();\n\n        this.darkColors = range(0, Math.floor(this.pal.length / 2));\n        this.brightColors = range(Math.floor(this.pal.length / 2), this.pal.length);\n\n        this.paletteRange = this.paletteChoices.colorsRange;\n        this.flipPalette = (this.sys.customize === undefined ? false : this.sys.customize.flipPalette);\n    }\n\n    override guessBlockParam(offset: number): void {\n    \n        let calculateHistogramForCell = (colors: number[], min: number, max: number) => {\n\n            let addToCurrent: AddToHistogramFromCurrentColorAtHandler = (x: number, y: number, color: number | undefined, histogram: Uint32Array) => {\n                if (color === undefined)\n                    return;\n\n                // because the result becomes \"pulled\" towards the\n                // reference image, the scoring needs to take into\n                // account that the palette may have chosen the\n                // other dark/bright versions instead so if the\n                // palette then flips choices, the \"pull\" will\n                // not happen properly if the previous color chosen\n                // previously is not present on the new palette\n                if ((color < min) || (color > max))\n                    this.addToHistogramFromCurrentColor(color ^ 0b1000, histogram);\n                else\n                    this.addToHistogramFromCurrentColor(color, histogram);\n\n            };\n\n            // reset histogram values\n            this.histogram.fill(0);\n            this.scores.fill(0);\n\n            // rank all colors within the size of the block (and bordering values)\n            this.addToBlockHistogramFromCurrentColor(offset, this.histogram, this.allColors, undefined, addToCurrent);\n            let scored = this.addToBlockHistogramFromAlt(offset, this.histogram, this.scores, colors);\n\n            let choices = this.getScoredChoicesByCount(scored);\n            return choices;\n        };\n\n        // The Zx spectrum requires that the colors chosen be either both from the\n        // bright spectrum of the palette or both from the dark spectrum of the palette.\n        // This choice of bright or not bright is applied to the entire cell and mixing\n        // a bright or non-bright color for a cell is not possible.\n        //\n        // As such, the routine picks the best two colors from the dark palette and\n        // picks the best two colors from the bright palette. Then the dark palette\n        // is scored against the bright palette. If the bright palette better\n        // represents the color (by having the \"closest\" rgb score), then the bright\n        // color is chosen otherwise the dark color is chosen by default.\n\n        // pick the top two colors from bright and dark mode\n        let choices1 = calculateHistogramForCell(this.darkColors, this.darkColors[0], this.darkColors[this.darkColors.length - 1]).slice(0, 2);\n        let choices2 = calculateHistogramForCell(this.brightColors, this.brightColors[0], this.brightColors[this.brightColors.length - 1]).slice(0, 2);\n\n        if (choices1.length < 2)\n            choices1.push(choices1[0]);\n        if (choices2.length < 2)\n            choices2.push(choices2[0]);\n\n        runtime_assert(choices1.length >= 2);\n        runtime_assert(choices2.length >= 2);\n\n        let score1 = 0;\n        let score2 = 0;\n\n        choices1.forEach((x) => { score1 += x.score; });\n        choices2.forEach((x) => { score2 += x.score; });\n\n        let result = score2 < score1 ? choices2 : choices1;\n\n        if ((result[0].ind < this.paletteRange.min) || (result[0].ind > this.paletteRange.max)) {\n            // cannot choose what was chosen (because of palette restrictions) so swap to the\n            // other palette (even if it isn't the best representation of the color)\n            result = score2 < score1 ? choices1 : choices2;\n        }\n\n        runtime_assert(result[0].ind >= this.paletteRange.min);\n        runtime_assert(result[0].ind <= this.paletteRange.max);\n        runtime_assert(result[1].ind >= this.paletteRange.min);\n        runtime_assert(result[1].ind <= this.paletteRange.max);\n\n        if (this.flipPalette) {\n            result[0].ind = (result[0].ind ^ 0b1000);\n            result[1].ind = (result[1].ind ^ 0b1000);\n        }\n\n        let sorted = [result[0].ind, result[1].ind].sort((a, b) => a - b);\n        this.updateBlockColorParam(offset, sorted);\n    }\n}\n\nexport class Stic_Fgbg_Canvas extends CommonBlockParamDitherCanvas {\n\n    override init(): void {\n        super.init();\n    }\n\n    override guessBlockParam(offset: number): void {\n        // reset histogram values\n        this.histogram.fill(0);\n        this.scores.fill(0);\n\n        // rank all colors within the size of the block (and bordering values)\n        this.addToBlockHistogramFromCurrentColor(offset, this.histogram, this.backgroundColors);\n        let scored = this.addToBlockHistogramFromAlt(offset, this.histogram, this.scores, this.backgroundColors);\n\n        let choices = this.getScoredChoicesByCount(scored);\n\n        let foregroundChoice: ScoredColorChoice | undefined;\n        for (let i = 0; i < choices.length; ++i) {\n            // filter out illegal options\n            if ((choices[i].ind < this.pixelPaletteChoices[0]) || (choices[i].ind > this.pixelPaletteChoices[this.pixelPaletteChoices.length-1]))\n                continue;\n            foregroundChoice = choices[i];\n            choices.splice(i, 1);   // do not let this option get chosen again\n            break;\n        }\n\n        // have to choose something, even if it's bad...\n        foregroundChoice = (foregroundChoice === undefined ? { count: 0, ind: this.pixelPaletteChoices[0], score: 0 } : foregroundChoice);\n\n        let colors = choices.map((x) => { return x.ind; } );\n        this.updateBlockColorParam(offset, [ foregroundChoice.ind, ...colors ]);\n    }\n\n}\n\nexport class Stic_ColorStack_Canvas extends CommonBlockParamDitherCanvas {\n\n    colorStack: number[] = [0, 0, 0, 0];\n\n    indirection: number[][] = [];\n\n    singleColorMode: boolean;\n\n    override init(): void {\n        super.init();\n\n        this.singleColorMode = (this.sys.customize === undefined ? false : this.sys.customize.singleColor);\n\n        this.makeIndirectionCombinations([]);\n        this.chooseColorStack();\n\n        // no longer need a redirection table\n        this.indirection = [];\n    }\n\n    makeIndirectionCombinations(current: number[]) {\n        if (current.length == this.colorStack.length) {\n            this.indirection.push(current)\n            return;\n        }\n\n        for (let i = 0; i < this.colorStack.length; ++i) {\n            let found = current.find((x) => x == i);\n            if (found !== undefined)\n                continue;\n\n            // new legal combination\n            this.makeIndirectionCombinations([...current, i]);\n        }\n    }\n\n    chooseColorStack(): void {\n\n        let chooseColors = (useColors: number[]) => {\n\n            let useColorStack = [ ...this.colorStack ];\n\n            this.histogram.fill(0);\n            this.scores.fill(0);\n\n            let lastScored: ScoredColorChoice[];\n            for (let offset = 0; offset < this.cb.size; ++offset) {\n                lastScored = this.addToCbHistogramFromRef(offset, this.histogram, this.scores, useColors);\n            }\n            \n            // choose the top N colors for use in the color stack\n            let choices = this.getScoredChoicesByCount(lastScored).slice(0, useColorStack.length);\n\n            if (this.singleColorMode) {\n                // choose the top color\n                choices = choices.splice(0, 1);\n            }\n\n            // must have chosen at least one color\n            runtime_assert(choices.length > 0);\n\n            // fill the color stack with rotating choices if too few colors were chosen\n            let startLength = choices.length;\n            for (let i = 0; choices.length < useColorStack.length; ++i) {\n                choices.push(choices[i % startLength]);\n            }\n\n            // must now have exactly \"colorStack\" choices in length\n            runtime_assert(choices.length == useColorStack.length);\n\n            // figure out which pattern is most likely to be useful, create the \"default\" color stack\n            useColorStack = choices.map((x) => { return x.ind; });\n\n            let lowestCombination: number = NaN;\n\n            if (!this.singleColorMode) {\n\n                let gridScore: number[][] = [];\n\n                // score each color's value in being used at every block\n                for (let offset = 0; offset < this.cb.size; ++offset) {\n                    this.histogram.fill(0);\n                    this.scores.fill(0);\n\n                    this.histogram.fill(0);\n                    this.scores.fill(0);\n                    let ranking = this.addToCbHistogramFromRef(offset, this.histogram, this.scores, useColorStack);\n\n                    let rankedChoices = this.getScoredChoicesByCount(ranking);\n                    runtime_assert(rankedChoices.length <= useColorStack.length);\n\n                    let scoredColors: number[] = [];\n                    for (let n = 0; n < useColorStack.length; ++n) {\n                        let foundRank = useColorStack.length;\n                        for (let rank = 0; rank < rankedChoices.length; ++rank) {\n                            // find the rank of the choice by skipping over the rank that doesn't match the color\n                            if (rankedChoices[rank].ind != useColorStack[n])\n                                continue;\n                            foundRank = rank;\n                            break;\n                        }\n                        scoredColors.push(foundRank);\n                    }\n                    gridScore.push(scoredColors);\n                }\n\n                let lowestRank: number = NaN;\n                for (let i = 0; i < this.indirection.length; ++i) {\n\n                    // test this combination to see if it's a good choice\n                    let combination = this.indirection[i];\n\n                    let combinationRank = 0;\n                    let pos = 0;\n\n                    for (let offset = 0; offset < this.cb.size; ++offset) {\n                        let indexCurrent = combination[pos % useColorStack.length];\n                        let indexNext = combination[(pos + 1) % useColorStack.length];\n\n                        let rankCurrent = gridScore[offset][indexCurrent];\n                        let rankNext = gridScore[offset][indexNext];\n\n                        let useRank = rankCurrent;\n                        if (rankNext < rankCurrent) {\n                            // will want to advance color stack in this condition\n                            useRank = rankNext;\n                            ++pos;\n                        }\n                        combinationRank += useRank;\n                    }\n\n                    if ((combinationRank < lowestRank) || (Number.isNaN(lowestRank))) {\n                        lowestCombination = i;\n                        lowestRank = combinationRank;\n                    }\n                }\n            } else {\n                // all combinations are exactly the same since they all reference one color\n                lowestCombination = 0;\n            }\n\n            runtime_assert(!Number.isNaN(lowestCombination));\n\n            // have found the best possible combination, make a new color stack\n            let replacementColorStack: number[] = [];\n            for (let i = 0; i < this.indirection[lowestCombination].length; ++i) {\n                // re-arrange the current color stack based on the best combination\n                replacementColorStack.push(useColorStack[this.indirection[lowestCombination][i]]);\n            }\n\n            return replacementColorStack;\n        }\n\n        // attempt to fill and score the color choices for the full range\n        let fullColorStack = chooseColors(this.backgroundColors);\n        let fullScore = this.fillCb(fullColorStack);\n        let fullCbParams = new Uint32Array(this.cbParams);\n\n        // only do the pastel comparisons if the foreground colors are restricted due to GROM being used instead of GRAM\n        // and not in single color mode since the best color is chosen regardless of the palette magnitude difference\n        let hasRestrictedPalette = ((this.paletteChoices.colorsRange.max < this.paletteChoices.backgroundRange.max) && (!this.singleColorMode));\n\n        let pastelColorStack = (hasRestrictedPalette ? chooseColors(range(this.paletteChoices.colorsRange.max + 1, this.paletteChoices.backgroundRange.max + 1)) : fullColorStack);\n        let pastelScore = (hasRestrictedPalette ? this.fillCb(pastelColorStack) : fullScore);\n\n        // assume pastel will win\n        this.colorStack = pastelColorStack;\n\n        // If the pastel score is within the same magnitude of the full score (or even better) then choose the pastel colors.\n        // Generally using the pastel colors is favored because the BACKTAB cannot use the pastel colors in the foreground\n        // color, thus as long as the pastel colors aren't unusually bad as a choice for the color block choices then\n        // select those colors because otherwise they are not usable at all.\n        let pastelWins = (Math.ceil(Math.log2(pastelScore)) <= Math.ceil(Math.log2(fullScore)));\n\n        if (!pastelWins) {\n            // sorry pastel colors, you are a terrible choice, put back the full color range\n            this.cbParams = fullCbParams;\n            this.colorStack = fullColorStack;\n        }\n\n        // fill the extra params\n        for (let i = 0; i < this.colorStack.length; ++i) {\n            this.updateColorParam(i, this.extraParams, [ this.colorStack[i] ]);\n        }\n    }\n\n    fillCb(useColors: number[]): number {\n\n        // reset the scoring\n        let colorStackScore = 0;\n\n        // copy the chosen color stack into the extra params\n        this.colorStack.forEach((x, i) => { this.extraParams[i] = x; });\n        \n        if (!this.singleColorMode) {\n            let pos = 0;\n            for (let offset = 0; offset < this.cb.size; ++offset) {\n                let currentColor = useColors[pos % useColors.length];\n                let nextColor = useColors[(pos + 1) % useColors.length];\n\n                // can only choose the current color, or the next color in the color stack\n                let colors = (this.singleColorMode ? [ currentColor ] : [ currentColor, nextColor ]);\n\n                // reset the scratch histogram\n                this.histogram.fill(0);\n                this.scores.fill(0);\n                let scored = this.addToCbHistogramFromRef(offset, this.histogram, this.scores, colors);\n\n                let choices = this.getScoredChoicesByCount(scored);\n                runtime_assert(choices.length > 0);\n\n                let advance: number = choices[0].ind == nextColor ? 1 : 0;\n                colorStackScore += choices[0].score;\n\n                // store the chosen color cb color (and the boolean if the advancement had to happen to use this color)\n                this.updateCbColorParam(offset, [choices[0].ind, advance]);\n\n                if (advance)\n                    ++pos;\n            }\n        } else {\n            // only ever choose 1 color and never advance\n            for (let offset = 0; offset < this.cb.size; ++offset) {\n                let currentColor = useColors[0];\n                // store the chosen color cb color (and the boolean if the advancement had to happen to use this color)\n                this.updateCbColorParam(offset, [currentColor, 0]);\n            }\n        }\n\n        return colorStackScore;\n    }\n\n    override guessCellParams(): void {\n\n        if (!this.paramInfo.cell)\n            return;\n\n        let scoring: { offset: number, score: number } [] = [];\n\n        // strategically choose which cells can most benefit from the usage of pastel colors\n        for (let offset = 0; offset < this.cellParams.length; ++offset) {\n\n            let restrictColors = [ ...this.backgroundColors ];\n\n            // the first color is the color stack color\n            let cbColor = this.extractColorsFromCbParams(offset, 1)[0];\n    \n            let foundCbColorIndex = restrictColors.findIndex((x) => x == cbColor);\n            if (foundCbColorIndex >= 0) {\n                // this color is always available via the color block thus do not let it be wasted on a foreground color\n                restrictColors.splice(foundCbColorIndex, 1);\n            }\n\n            // reset histogram values\n            this.histogram.fill(0);\n            this.scores.fill(0);\n\n            // rank all colors within the size of the block\n            this.addToCellHistogramFromCurrentColor(offset, this.histogram, restrictColors);\n            let scored = this.addToCellHistogramFromAlt(offset, this.histogram, this.scores, restrictColors);\n\n            let choices = this.getScoredChoicesByCount(scored);\n            runtime_assert(choices.length > 0);\n\n            if ((choices[0].ind < this.paletteChoices.colorsRange.min) || (choices[0].ind > this.paletteChoices.colorsRange.max)) {\n                // this block would make use of a pastel color\n                scoring.push( { offset: offset, score: choices[0].score } );\n            } else {\n                scoring.push( { offset: offset, score: NaN } );\n            }\n        }\n\n        let filtered = scoring.filter((x) => !Number.isNaN(x.score));\n        let sorted = filtered.sort((a, b) => a.score - b.score);\n\n        // only have so many gram slots available, so pick not only those that would\n        // use the pastel color but those which are best represented by the pastel color\n        sorted = sorted.slice(0, 64);\n\n        // reset all the cell params to 0\n        this.cellParams.fill(0);\n\n        // a 1 indicates the this cell param is allowed to use the full range\n        sorted.forEach((x, index) => { this.updateCellColorParam(x.offset, [1, index], 0xff, 8); });\n    }\n\n    override guessBlockParam(offset: number): void {\n\n        let allowFullRange = false;\n        if (this.paramInfo.cell) {\n            // if the cell indicates it is allowed to use the full color range, then let it\n            allowFullRange = (this.extractColorsFromCellParams(offset, 1, 0xff, 8)[0] != 0);\n        }\n\n        let restrictColors = allowFullRange ? [ ...this.backgroundColors ] : [ ...this.pixelPaletteChoices ];\n\n        // the first color is the color stack color\n        let cbColor = this.extractColorsFromCbParams(offset, 1)[0];\n\n        let foundCbColorIndex = restrictColors.findIndex((x) => x == cbColor);\n        if (foundCbColorIndex >= 0) {\n            // this color is always available via the color block thus do not let it be wasted on a foreground color\n            restrictColors.splice(foundCbColorIndex, 1);\n        }\n\n        // reset histogram values\n        this.histogram.fill(0);\n        this.scores.fill(0);\n\n        // rank all colors within the size of the block (and bordering values)\n        this.addToBlockHistogramFromCurrentColor(offset, this.histogram, restrictColors);\n        let scored = this.addToBlockHistogramFromAlt(offset, this.histogram, this.scores, restrictColors);\n\n        let choices = this.getScoredChoicesByCount(scored);\n\n        let colors = (choices.map((x) => { return x.ind; } )).slice(0, this.paletteChoices.colors);\n        this.updateBlockColorParam(offset, colors);\n    }\n\n    override getValidColors(imageIndex: number): number[] {\n        let offset = this.imageIndexToBlockOffset(imageIndex);\n\n        let extracted = this.extractColorsFromBlockParams(offset, this.paletteChoices.colors);\n        let cbColor = this.extractColorsFromCbParams(offset, 1)[0];\n\n        let valid: number[] = [ cbColor, ...extracted ];\n        return valid;\n    }\n}\n\nexport class Msx_Canvas extends CommonBlockParamDitherCanvas {\n}\n\nexport class SNES_Canvas extends CommonBlockParamDitherCanvas {\n}\n\nexport class SNES_Canvas_Direct extends CommonBlockParamDitherCanvas {\n\n    Bbpgggprrrp_to_Pal_Lut: Uint32Array;\n\n    pppFilteredPalettes: number[][] = [];\n\n    override init(): void {\n        super.init();\n\n        this.Bbpgggprrrp_to_Pal_Lut = new Uint32Array(this.pal.length);\n        \n        for (let i = 0; i < this.pal.length; ++i) {\n            let info = this.RgbToInfo(this.pal[i]);\n            this.Bbpgggprrrp_to_Pal_Lut[info.bbpgggprrrp] = i;\n        }\n\n        for (let ppp = 0; ppp < (1 << 3); ++ppp) {\n            let filteredByPpp = this.pixelPaletteChoices.filter((x) => { let info = this.colorToInfo(x); return (info.ppp == ppp) && (!(info.bbpgggprrrp == 0)); } );\n            this.pppFilteredPalettes.push(filteredByPpp);\n        }\n    }\n\n    RgbToInfo(rgb: number): { bbpgggprrrp: number, bbgggrrr :number, ppp: number, r: number, g: number, b: number } {\n        let bbpgggprrrp = ((rgb & 0b11110000) >> 4) | ((((rgb >> 8) & 0b11110000) >> 4) << 4) | ((((rgb >> 16) & 0b11100000) >> 5) << 8);\n        let bbgggrrr = ((rgb & 0b11100000) >> 5) | ((((rgb >> 8) & 0b11100000) >> 5) << 3) | ((((rgb >> 16) & 0b11000000) >> 6) << 6);\n        let ppp = ((rgb & 0b00010000) >> 4) | ((((rgb >> 8) & 0b00010000) >> 4) << 1) | ((((rgb >> 16) & 0b00100000) >> 5) << 2);\n        let r = (rgb & 0b11110000);\n        let g = ((rgb >> 8) & 0b11110000);\n        let b = ((rgb >> 16) & 0b11100000);\n\n        return { bbpgggprrrp, bbgggrrr, ppp, r, g, b };\n    }\n\n    BbgggrrrToBbpgggprrrp(bbgggrrr: number, ppp: number): number {\n\n        let bbpgggprrrp = ((bbgggrrr & 0b00000111) << 1) | (((bbgggrrr & 0b00111000) >> 3) << 4) | (((bbgggrrr & 0b11000000) >> 6) << 9);\n        bbpgggprrrp |= (ppp & 0b001) | (((ppp & 0b010) >> 1) << 4) | (((ppp & 0b100) >> 2) << 8);\n        return bbpgggprrrp;\n    }\n\n    BbpgggprrrpToInfo(bbpgggprrrp: number): { rgb: number, bbgggrrr :number, ppp: number, r: number, g: number, b: number } {\n        let rgb = ((bbpgggprrrp & 0b00000001111) << (0 + 4)) | (((bbpgggprrrp & 0b00011110000) >> 4) << (8 + 4)) | (((bbpgggprrrp & 0b11100000000) >> 8) << (16 + 5));\n        let bbgggrrr = ((bbpgggprrrp & 0b00000001110) >> 1) | (((bbpgggprrrp & 0b00011100000) >> 5) << 3) | (((bbpgggprrrp & 0b11000000000) >> 9) << 6);\n        let ppp = (bbpgggprrrp & 0b00000000001) | (((bbpgggprrrp & 0b00000010000) >> 4) << 1) | (((bbpgggprrrp & 0b00100000000) >> 8) << 2);\n\n        let r = (rgb & 0b11110000);\n        let g = ((rgb >> 8) & 0b11110000);\n        let b = ((rgb >> 16) & 0b11100000);\n\n        return { rgb, bbgggrrr, ppp, r, g, b };\n    }\n\n    BbpgggprrrpToColor(bbpgggprrrp: number): number {\n        return this.Bbpgggprrrp_to_Pal_Lut[bbpgggprrrp];\n    }\n\n    colorToInfo(color: number): { bbpgggprrrp: number, bbgggrrr :number, ppp: number } {\n        return this.RgbToInfo(this.pal[color]);\n    }\n\n    substituteColorForColorWithPpp(currentColor: number, ppp: number): number {\n        let info = this.colorToInfo(currentColor);\n        return this.BbpgggprrrpToColor(this.BbgggrrrToBbpgggprrrp(info.bbgggrrr, ppp));\n    }\n\n    override getValidColors(imageIndex: number): number[] {\n\n        let offset = this.imageIndexToBlockOffset(imageIndex);\n\n        let ppp = this.extractColorsFromBlockParams(offset, 1, 0x3, 2)[0];\n\n        // return palette filter to legal values with the same ppp\n        let valid = this.pppFilteredPalettes[ppp];\n        return valid;\n    }\n\n    override guessBlockParam(offset: number): void {\n\n        // reset histogram values\n        this.histogram.fill(0);\n        this.scores.fill(0);\n\n        // rank all colors regardless of which ppp value they might have selected\n        this.addToBlockHistogramFromCurrentColor(offset, this.histogram);\n        let scored = this.addToBlockHistogramFromAlt(offset, this.histogram, this.scores);\n\n        let ranked = this.getScoredChoicesByCount(scored);\n\n        let lowestPpp = NaN;\n        let lowestPppScore = NaN;\n        for (let ppp = 0; ppp < (1 << 3); ++ppp) {\n\n            // construct a restricted palette color table based on the ppp (which may contain duplicate values)\n            let restrictedColors: number[] = ranked.map((x) => { return this.substituteColorForColorWithPpp(x.ind, ppp); });\n\n            // remove these duplicate values\n            restrictedColors = Array.from(new Set(restrictedColors));\n\n            this.histogram.fill(0);\n            this.scores.fill(0);\n    \n            this.addToBlockHistogramFromCurrentColor(offset, this.histogram, restrictedColors);\n            let scored = this.addToBlockHistogramFromAlt(offset, this.histogram, this.scores, restrictedColors);\n\n            let pppRanked = this.getScoredChoicesByCount(scored);\n\n            let totalPppScore = 0;\n            pppRanked.forEach((x) => { totalPppScore += x.score });\n\n            if ((totalPppScore < lowestPppScore) || (Number.isNaN(lowestPppScore))) {\n                lowestPppScore = totalPppScore;\n                lowestPpp = ppp;\n            }\n        }\n\n        // found the ppp value to use for this particular cell\n        runtime_assert(!Number.isNaN(lowestPpp));\n\n        // store the ppp value into the block color (since the this.indexed will hold the actual color)\n        this.updateBlockColorParam(offset, [ lowestPpp ], 0x3, 2);\n    }\n\n}\n\nexport class NES_Canvas extends BasicParamDitherCanvas {\n    w = 16;\n    h = 16;\n    allColors = [0, 1, 2, 3, 4];\n    init() {\n        this.params = new Uint32Array(this.width / this.w * this.height / this.h);\n        for (var i = 0; i < this.params.length; i++) {\n            this.guessParam(i);\n        }\n    }\n    getValidColors(offset: number) {\n        var ncols = this.width / this.w;\n        var col = Math.floor(offset / this.w) % ncols;\n        var row = Math.floor(offset / (this.width * this.h));\n        var i = col + row * ncols;\n        var c1 = this.params[i];\n        // param specified which color to leave out\n        switch (c1 & 3) {\n            case 0: return [0, 2, 3, 4];\n            case 1: return [0, 1, 3, 4];\n            case 2: return [0, 1, 2, 4];\n            case 3: return [0, 1, 2, 3];\n        }\n        throw new Error(\"invalid param \" + c1);\n    }\n    guessParam(p: number) {\n        var ncols = this.width / this.w;\n        var col = p % ncols;\n        var row = Math.floor(p / ncols);\n        var offset = col * this.w + row * this.width * this.h;\n        var colors = [1, 2, 3, 4];\n        // rank all colors\n        var histo = new Uint32Array(16);\n        var b = 8; // border (TODO: param)\n        for (var y = -b; y < this.h + b; y++) {\n            var o = offset + y * this.width;\n            for (var x = -b; x < this.w + b; x++) {\n                // get current color (or reference for 1st time)\n                var c1 = this.indexed[o + x] | 0;\n                histo[c1] += 100;\n                // get error color (TODO: why ref works better?)\n                var rgbcomp = this.alt[o + x] | 0;\n                var c2 = this.getClosest(rgbcomp, colors);\n                histo[c2] += 1 + this.noise;\n            }\n        }\n        var choices = getChoices(histo);\n        // leave out last color, least frequent\n        choices.forEach((ch) => {\n            if (ch.ind >= 1 && ch.ind <= 4) this.params[p] = ch.ind - 1;\n        });\n    }\n}\n\nexport class HAM6_Canvas extends DitheringCanvas {\n    getValidColors(offset: number): number[] {\n        let arr = super.getValidColors(offset);\n        if (offset == 0) {\n            arr = arr.slice(0, 16);\n        } else {\n            let palindex = 16;\n            let prevrgb = this.img[offset - 1];\n            for (let chan = 0; chan < 3; chan++) {\n                for (let i = 0; i < 16; i++) {\n                    let rgb = prevrgb;\n                    rgb &= ~(0xff << (chan * 8));\n                    rgb |= (i << 4) << (chan * 8);\n                    this.pal[palindex++] = rgb;\n                }\n            }\n        }\n        return arr;\n    }\n}\n", "import { support } from \"jquery\";\nimport { getChoices, getClosestRGB, getRGBADiff, getRGBAErrorPerceptual, reducePaletteChoices, ColorChoice } from \"../common/color\";\nimport {\n    DitherKernel,\n    DithertronSettings,\n    RGBDistanceFunction,\n    PaletteChoices,\n    PaletteRange,\n    BlockBasics,\n    BlockColors,\n    BlockSizing,\n    BlockBitOrder,\n    BlockColorBleed,\n    Param\n} from \"../common/types\";\nimport { range, runtime_assert } from \"../common/util\";\n\nconst THRESHOLD_MAP_4X4 = [\n    0, 8, 2, 10,\n    12, 4, 14, 6,\n    3, 11, 1, 9,\n    15, 7, 13, 5,\n];\n\nexport class BaseDitheringCanvas {\n    sys: DithertronSettings;\n    pal: Uint32Array;\n    img: Uint32Array;\n    ref: Uint32Array;\n    alt: Uint32Array;\n    err: Float32Array; // (n*3)\n    indexed: Uint32Array;\n    width: number; // integer\n    height: number;\n    tmp: Uint8ClampedArray;\n    tmp2: Uint32Array;\n    changes: number;\n    noise: number = 0;\n    diffuse: number = 0.8;\n    ordered: number = 0.0;\n    ditherfn: DitherKernel = [];\n    errfn: RGBDistanceFunction = getRGBAErrorPerceptual;\n    errorThreshold = 0;\n    iterateCount: number = 0;\n    params: Uint32Array;\n    content(): any { return { params: this.params }; };\n\n    constructor(img: Uint32Array, width: number, pal: Uint32Array) {\n        this.img = img;\n        for (var i = 0; i < pal.length; i++)\n            pal[i] |= 0xff000000;\n        this.pal = new Uint32Array(pal);\n        this.width = width;\n        this.height = Math.floor(img.length / width);\n        this.tmp = new Uint8ClampedArray(4);\n        this.tmp2 = new Uint32Array(this.tmp.buffer);\n        this.ref = new Uint32Array(img);\n        this.alt = new Uint32Array(this.ref);\n        this.err = new Float32Array(this.ref.length * 3);\n        this.indexed = new Uint32Array(this.ref.length);\n        this.changes = 0;\n        this.reset();\n    }\n    reset() {\n        this.img = new Uint32Array(this.ref);\n        this.alt.set(this.ref);\n        this.err.fill(0);\n        this.indexed.fill(0);\n        this.changes = 0;\n    }\n    init() : void {\n    }\n    update(offset: number) {\n        var errofs = offset * 3;\n        var rgbref = this.ref[offset];\n        // add cumulative error to pixel color, store into a clamped R,G, and B values (0-255) array\n        var ko = 1;\n        if (this.ordered > 0) {\n            let x = (offset % this.width) & 3;\n            let y = (offset / this.width) & 3;\n            ko = 1 + (THRESHOLD_MAP_4X4[x + y * 4] / 15 - 0.5) * this.ordered;\n        }\n        this.tmp[0] = (rgbref & 0xff) * ko + this.err[errofs];\n        this.tmp[1] = ((rgbref >> 8) & 0xff) * ko + this.err[errofs + 1];\n        this.tmp[2] = ((rgbref >> 16) & 0xff) * ko + this.err[errofs + 2];\n        // store the error-modified color\n        this.alt[offset] = this.tmp2[0];\n        // find closest palette color\n        var valid = this.getValidColors(offset);\n        var palidx = this.getClosest(this.tmp2[0], valid);\n        var rgbimg = this.pal[palidx];\n        // compute error and distribute to neighbors\n        var err = getRGBADiff(rgbref, rgbimg);\n        for (var i = 0; i < 3; i++) {\n            var k = (this.err[errofs + i] + err[i]) * this.diffuse;\n            // TODO: don't wrap off right edge?\n            this.ditherfn.forEach((df) => {\n                this.err[errofs + i + (df[0] + df[1] * this.width) * 3] += k * df[2];\n            });\n            this.err[errofs + i] = 0; // reset this pixel's error\n        }\n        // set new pixel rgb\n        const errmag = (Math.abs(err[0]) + Math.abs(err[1]*2) + Math.abs(err[2])) / (256 * 4);\n        if (this.indexed[offset] != palidx) {\n            let shouldChange = (errmag >= this.errorThreshold);\n            if (!shouldChange) {\n                let existingValue = this.indexed[offset];\n                // double check the old value is still legal since changing the value is not desired\n                shouldChange = (valid.find((x) => existingValue === x) === undefined);\n            }\n            if (shouldChange) {\n                this.indexed[offset] = palidx;\n                this.changes++;\n            }\n        }\n        this.img[offset] = rgbimg;\n        //this.img[offset] = this.tmp2[0] | 0xff000000;\n    }\n    getClosest(rgb: number, inds: number[]) {\n        return getClosestRGB(rgb, inds, this.pal, this.errfn);\n    }\n    iterate() {\n        this.changes = 0;\n        // WARNING: commit must be called prior to update otherwise the\n        // update can happen without the image reflecting the new color\n        // choices. Not only is the image seen potentially out of sync for\n        // the user, but this can also cause some cell bitmap patterns to\n        // fail on some pixels as these pixel chose a color that is not\n        // present in the color params.\n        this.commit();\n        for (var i = 0; i < this.img.length; i++) {\n            this.update(i);\n        }\n        this.iterateCount++;\n    }\n    commit() {\n        //\n    }\n    getValidColors(imageIndex: number): number[] {\n        return range(0, this.pal.length);\n    }\n}\n\nexport interface ParamsContent {\n    params: Uint32Array;\n};\n\nexport abstract class ParamDitherCanvas extends BaseDitheringCanvas {\n    params: Uint32Array = new Uint32Array(0);\n\n    abstract guessParam(paramIndex: number): void;\n\n    abstract init(): void;\n\n    override commit(): void {\n        for (var i = 0; i < this.params.length; i++) {\n            this.guessParam(i);\n        }\n    }\n\n    override content() : ParamsContent {\n        return {\n            params: this.params\n        };\n    }\n}\n\nexport abstract class BasicParamDitherCanvas extends ParamDitherCanvas {\n    abstract w: number;\n    abstract h: number;\n\n    override init(): void {\n        this.params = new Uint32Array(this.width * this.height / this.w);\n        for (var i = 0; i < this.params.length; i++) {\n            this.guessParam(i);\n        }\n    }\n}\n\n// TODO: both colors affected by bright bit\nexport abstract class TwoColor_Canvas extends BasicParamDitherCanvas {\n    ncols: number = 0;\n    nrows: number = 0;\n    border: number = 0;\n    allColors: number[] | null = null;\n\n    init() {\n        if (!this.allColors) this.allColors = range(0, this.pal.length);\n        this.indexed.fill(this.allColors[0]);\n        this.ncols = this.width / this.w;\n        this.nrows = this.height / this.h;\n        this.params = new Uint32Array(this.ncols * this.nrows);\n        for (var i = 0; i < this.params.length; i++) {\n            this.guessParam(i);\n        }\n    }\n    override getValidColors(imageIndex: number) {\n        var col = Math.floor(imageIndex / this.w) % this.ncols;\n        var row = Math.floor(imageIndex / (this.width * this.h));\n        var i = col + row * this.ncols;\n        var c1 = this.params[i] & 0xff;\n        var c2 = (this.params[i] >> 8) & 0xff;\n        return [c1, c2];\n    }\n    guessParam(p: number) {\n        var col = p % this.ncols;\n        var row = Math.floor(p / this.ncols);\n        var offset = col * this.w + row * (this.width * this.h);\n        var colors = this.allColors!;\n        var histo = new Uint32Array(256);\n        // pixel overlap in 8x8 window\n        var b = this.border; // border\n        for (var y = -b; y < this.h + b; y++) {\n            var o = offset + y * this.width;\n            for (var x = -b; x < this.w + b; x++) {\n                var c1 = this.indexed[o + x] | 0;\n                histo[c1] += 100;\n                var c2 = this.getClosest(this.alt[o + x] | 0, colors);\n                histo[c2] += 1 + this.noise;\n            }\n        }\n        var choices = getChoices(histo);\n        this.updateParams(p, choices);\n    }\n    updateParams(p: number, choices: { ind: number }[]) {\n        var ind1 = choices[0].ind;\n        var ind2 = choices[1] ? choices[1].ind : ind1;\n        if (ind1 > ind2) {\n            var tmp = ind1;\n            ind1 = ind2;\n            ind2 = tmp;\n        }\n        this.params[p] = ind1 + (ind2 << 8);\n    }\n}\n\nexport abstract class OneColor_Canvas extends TwoColor_Canvas {\n    bgColor: number = 0;\n\n    init() {\n        /*\n        var choices = reducePaletteChoices(this.ref, this.pal, 2, 1, this.errfn);\n        this.bgColor = choices[choices.length-1].ind;\n        this.allColors = [1,2,3,4,5,6,7].filter(x => x != this.bgColor);\n        console.log(this.bgColor, this.allColors);\n        */\n        this.bgColor = 0;\n        super.init();\n    }\n    override getValidColors(imageIndex: number) {\n        return [this.bgColor, super.getValidColors(imageIndex)[0]];\n    }\n    updateParams(p: number, choices: { ind: number }[]) {\n        for (let c of choices) {\n            if (c.ind != this.bgColor) {\n                this.params[p] = c.ind;\n                break;\n            }\n        }\n    }\n}\n\nexport interface BlockParamDitherCanvasContent {\n    width: number;\n    height: number;\n\n    block: BlockBasics & BlockColors & BlockSizing & BlockBitOrder;\n    cb: BlockBasics & BlockSizing & BlockBitOrder;\n    cell: BlockBasics & BlockSizing & BlockBitOrder;\n\n    fliMode: boolean;\n    fullPaletteMode: boolean;\n\n    paramInfo: Required<Param>;\n    \n    bitsPerColor: number;\n    pixelsPerByte: number;\n\n    // values chosen base on image\n    backgroundColor: number;\n    auxColor: number;\n    borderColor: number;\n \n    paletteChoices: PaletteChoices;\n    paletteBits: number;\n    paletteBitFilter: number;\n\n    blockParams: Uint32Array;\n    cbParams: Uint32Array;\n    cellParams: Uint32Array;\n    extraParams: Uint32Array;\n}\n\nexport type AddToHistogramFromCurrentColorAtHandler = (x: number, y: number, color: number | undefined, histogram: Uint32Array) => void;\nexport type AddToHistogramFromClosestAtHandler = (x: number, y: number, closest: ClosestScore | undefined, histogram: Uint32Array) => void;\n\nexport abstract class BlockParamDitherCanvas extends BaseDitheringCanvas {\n    blockParams: Uint32Array = new Uint32Array(0);\n    cbParams: Uint32Array = new Uint32Array(0);\n    cellParams: Uint32Array = new Uint32Array(0);\n    extraParams: Uint32Array = new Uint32Array(0);\n\n    block: BlockBasics & BlockColors & BlockSizing & BlockColorBleed & BlockBitOrder;\n    cb: BlockBasics & BlockSizing & BlockColorBleed & BlockBitOrder;\n    cell: BlockBasics & BlockSizing  & BlockColorBleed & BlockBitOrder;\n\n    fliMode: boolean = false;\n    fullPaletteMode: boolean = false;\n\n    paramInfo: Required<Param>;\n    \n    bitsPerColor: number;\n    pixelsPerByte: number;\n\n    paletteChoices: PaletteChoices;\n    paletteBits = Math.ceil(Math.log2(this.pal.length));\n    paletteBitFilter = ((1 << this.paletteBits) - 1);\n\n    // values chosen base on image\n    backgroundColor: number = 0;\n    auxColor: number = 0;\n    borderColor: number = 0;\n\n    content(): BlockParamDitherCanvasContent {\n        return {\n            width: this.width,\n            height: this.height,\n\n            block: this.block,\n            cb: this.cb,\n            cell: this.cell,\n\n            fullPaletteMode: this.fullPaletteMode,\n\n            fliMode: this.fliMode,\n            paramInfo: this.paramInfo,\n\n            bitsPerColor: this.bitsPerColor,\n            pixelsPerByte: this.pixelsPerByte,\n\n            backgroundColor: this.backgroundColor,\n            borderColor: this.borderColor,\n            auxColor: this.auxColor,\n            \n            paletteChoices: this.paletteChoices,\n            paletteBits: this.paletteBits,\n            paletteBitFilter: this.paletteBitFilter,\n\n            blockParams: this.blockParams,\n            cbParams: this.cbParams,\n            cellParams: this.cellParams,\n            extraParams: this.extraParams,\n        }\n    }\n\n    // functions that are designed to be overridden\n    override init(): void {\n        super.init();        \n    }\n    abstract prepare(): void;\n\n    abstract prepareDefaults(): void;\n    abstract prepareGlobalColorChoices(): void;\n    abstract allocateParams(): void;\n\n    abstract currentColorAtXY(x: number, y: number, orColor?: number): number;\n    abstract addToHistogramAtXYFromCurrentColor(x: number, y: number, color: number | undefined, histogram: Uint32Array);\n    abstract addToHistogramFromClosestAtXY(x: number, y: number, closest: ClosestScore | undefined, histogram: Uint32Array, scores: Uint32Array): void;\n\n    override commit(): void {\n        super.commit();\n    }\n\n    override getValidColors(imageIndex: number): number[] {\n        return super.getValidColors(imageIndex);\n    }\n\n    abstract guessBlockParams(): void;\n    abstract guessCbParams(): void;\n    abstract guessCellParams(): void;\n    abstract guessExtraParams(): void;\n\n    abstract guessBlockParam(offset: number): void;\n    abstract guessCbParam(offset: number): void;\n    abstract guessCellParam(offset: number): void;\n    abstract guessExtraParam(offset: number): void;\n};\n\nexport interface ScoredColorChoice extends ColorChoice {\n    score: number\n};\n\nexport interface BlockInfo extends BlockBasics, BlockSizing {\n};\n\nexport interface ExtendedBlockInfo extends BlockBasics, BlockSizing, Required<BlockColorBleed> {\n};\n\nexport interface ClosestScore {\n    closestColor: number,\n    closestScore: number\n};\n\nexport function extractColorsFromParam(param: number, totalToExtract: number, paletteBitFilter: number, paletteBits: number): number[] {\n    if (0 == totalToExtract)\n        return [];\n\n    let value = param;\n\n    let result: number[] = [];\n    while (totalToExtract > 0) {\n        result.push(value & paletteBitFilter);\n        value >>= paletteBits;\n        --totalToExtract;\n    }\n    return result;\n}\n\nexport function extractColorsFromParamContent(param: number, totalToExtract: number, content: { paletteBitFilter: number, paletteBits: number}): number[] {\n    return extractColorsFromParam(param, totalToExtract, content.paletteBitFilter, content.paletteBits);\n}\n\nexport function extractColorsFromParams(offset: number, params: Uint32Array, totalToExtract: number, paletteBitFilter: number, paletteBits: number): number[] {\n    if (0 == totalToExtract)\n        return [];\n    runtime_assert(offset < params.length);\n    return extractColorsFromParam(params[offset], totalToExtract, paletteBitFilter, paletteBits);\n}\n\nexport function extractColorsFromParamsContent(offset: number, params: Uint32Array, totalToExtract: number, content: { paletteBitFilter: number, paletteBits: number}): number[] {\n    return extractColorsFromParams(offset, params, totalToExtract, content.paletteBitFilter, content.paletteBits);\n}\n\nexport abstract class CommonBlockParamDitherCanvas extends BlockParamDitherCanvas {\n\n    paletteChoices: Required<PaletteChoices>;\n    pixelPaletteChoices: number[];\n\n    // legal color indices for various ranges\n    allColors: number[];            // colors for the entire palette range\n    backgroundColors: number[];     // colors legal for the background color\n    auxColors: number[];            // colors legal for the aux color\n    borderColors: number[];         // colors legal for the border color\n    blockColors: number[];          // colors legal for block colors (excluding any selectable background, border, aux colors)\n\n    globalValid: number[] = [];     // an array of selectable global colors\n\n    foundColorsByUsage: ColorChoice[] = [];             // which colors best represent the entire image\n    foundColorsByColorIntensity: ColorChoice[] = [];    // which colors are most compatible ranked by intensity\n\n    histogramScoreCurrent: number = 100;\n\n    histogram = new Uint32Array(this.pal.length);   // temporary scratch histogram buffer\n    scores = new Uint32Array(this.pal.length);      // temporary scratch scores buffer\n\n    firstCommit = false;\n\n    override init() : void {\n        this.prepare();\n    }\n    override prepare() : void {\n        super.init();\n        this.prepareDefaults();\n        this.prepareGlobalColorChoices();\n        this.allocateParams();\n\n        let bestPrefill = () => {\n            if (this.pixelPaletteChoices.length > 0)\n                return this.pixelPaletteChoices[0];\n            if (this.allColors.length > 0)\n                return this.allColors[0];\n            return this.backgroundColor;\n        };\n\n        this.indexed.fill(bestPrefill());\n    }\n    override prepareDefaults(): void {\n        this.block = {\n            w: (this.sys.block === undefined ?\n                    (this.sys.cell === undefined ? this.sys.cb.w : this.sys.cell.w) :\n                    this.sys.block.w),\n            h: (this.sys.block === undefined ?\n                    (this.sys.cell === undefined ? this.sys.cb.h : this.sys.cell.h) :\n                    this.sys.block.h),\n            colors: (this.sys.block === undefined ? 2 : this.sys.block.colors ),\n            xb: (this.sys.block === undefined ?\n                    (this.sys.cb === undefined ? 0 :\n                        (this.sys.cb.xb === undefined ? 0 : this.sys.cb.xb)) :\n                    (this.sys.block.xb === undefined ? 0 : this.sys.block.xb)),\n            yb: (this.sys.block === undefined ?\n                    (this.sys.cb === undefined ? 0 :\n                        (this.sys.cb.yb === undefined ? 0 : this.sys.cb.yb)) :\n                    (this.sys.block.yb === undefined ? 0 : this.sys.block.yb)),\n            columns: 0,\n            rows: 0,\n            size: 0,\n            msbToLsb: (this.sys.block === undefined ? true : (this.sys.block.msbToLsb === undefined ? true : this.sys.block.msbToLsb))\n        };\n        this.block.columns = Math.ceil(this.width / this.block.w);\n        this.block.rows = Math.ceil(this.height / this.block.h);\n        this.block.size = this.block.columns * this.block.rows;\n\n        this.cb = {\n            w: (this.sys.cb === undefined ? this.block.w : this.sys.cb.w),\n            h: (this.sys.cb === undefined ? this.block.h : this.sys.cb.h),\n            xb: (this.sys.cb === undefined ?\n                    this.block.xb :\n                    (this.sys.cb.xb === undefined ? this.block.xb : this.sys.cb.xb)),\n            yb: (this.sys.cb === undefined ?\n                    this.block.yb :\n                    (this.sys.cb.yb === undefined ? this.block.yb : this.sys.cb.yb)),\n            columns: 0,\n            rows: 0,\n            size: 0,\n            msbToLsb: (this.sys.cb === undefined ? true : (this.sys.cb.msbToLsb === undefined ? true : this.sys.cb.msbToLsb))\n        };\n        this.cb.columns = Math.ceil(this.width / this.cb.w);\n        this.cb.rows = Math.ceil(this.height / this.cb.h);\n        this.cb.size = this.cb.columns * this.cb.rows;\n\n        this.cell = {\n            w: (this.sys.cell === undefined ? this.cb.w : this.sys.cell.w),\n            h: (this.sys.cell === undefined ? this.cb.h : this.sys.cell.h),\n            xb: (this.sys.cell === undefined ?\n                    this.block.xb :\n                    (this.sys.cell.xb === undefined ? this.block.xb : this.sys.cell.xb)),\n            yb: (this.sys.cell === undefined ?\n                    this.block.yb :\n                    (this.sys.cell.yb === undefined ? this.block.yb : this.sys.cell.yb)),\n            columns: 0,\n            rows: 0,\n            size: 0,\n            msbToLsb: (this.sys.cell === undefined ? true : this.sys.cell.msbToLsb)\n        };\n        this.cell.columns = Math.ceil(this.width / this.cell.w);\n        this.cell.rows = Math.ceil(this.height / this.cell.h);\n        this.cell.size = this.cell.rows * this.cell.columns;\n\n        this.fliMode = (this.sys.fli !== undefined);\n        this.paramInfo = {\n            block: (this.sys.param === undefined ? (this.sys.block !== undefined) : (this.sys.param.block === undefined ? this.sys.block !== undefined : this.sys.param.block)),\n            cb: (this.sys.param === undefined ? (this.sys.cb !== undefined) : (this.sys.param.cb === undefined ? this.sys.cb !== undefined : this.sys.param.cb)),\n            cell: (this.sys.param === undefined ? false : (this.sys.param.cell === undefined ? false : this.sys.param.cell)),\n            extra: (this.sys.param === undefined ? 0 : this.sys.param.extra)\n        };\n\n        this.bitsPerColor = Math.ceil(Math.log2(this.block.colors));\n        this.pixelsPerByte = Math.floor(8 / this.bitsPerColor);\n\n        runtime_assert(this.paletteBits > 0);\n\n        this.preparePaletteChoices(this.sys.paletteChoices);\n\n        // if the number of chosen colors is greater than the palette size there's no need to store color choices\n        this.fullPaletteMode = (this.paletteChoices.colors >= this.pal.length);\n        this.firstCommit = this.paletteChoices.prefillReference;\n    }\n    spliceColor(color: number, colors: number[]): number[] {\n        let found = colors.findIndex((x) => x == color);\n        if (found < 0)\n            return colors;\n        return [... colors.slice(0, found), ... colors.slice(found+1) ];\n    }\n    preparePixelPaletteChoices(): void {\n        let count : number = this.paletteChoices.colorsRange.max - this.paletteChoices.colorsRange.min + 1;\n        this.pixelPaletteChoices = range(this.paletteChoices.colorsRange.min, this.paletteChoices.colorsRange.max + 1);\n\n        this.allColors = range(0, this.pal.length);\n        this.backgroundColors = range(this.paletteChoices.backgroundRange.min, this.paletteChoices.backgroundRange.max+1);\n        this.auxColors = range(this.paletteChoices.auxRange.min, this.paletteChoices.auxRange.max+1);\n        this.borderColors = range(this.paletteChoices.borderRange.min, this.paletteChoices.borderRange.max+1);\n        this.blockColors = range(this.paletteChoices.colorsRange.min, this.paletteChoices.colorsRange.max+1);\n    }\n    preparePaletteChoices(options?: Partial<PaletteChoices>):void {\n        runtime_assert(this.pal.length > 0);\n        if (options === undefined) {\n            this.paletteChoices = {\n                prefillReference: false,\n                background: false,\n                aux: false,\n                border:  false,\n                backgroundRange: { min: 0, max: this.pal.length - 1 },\n                auxRange: { min: 0, max: this.pal.length - 1 },\n                borderRange: { min: 0, max: this.pal.length - 1 },\n                colors: this.block.colors,\n                colorsRange: { min: 0, max: this.pal.length - 1 }\n            };\n            this.preparePixelPaletteChoices();\n            return;\n        }\n        this.paletteChoices = {\n            prefillReference: options.prefillReference === undefined ? false : options.prefillReference,\n            background: options.background === undefined ? false : options.background,\n            aux: options.aux === undefined ? false : options.aux,\n            border:  options.aux === undefined ? false : options.border,\n            backgroundRange: options.backgroundRange === undefined ? { min: 0, max: this.pal.length - 1 } : options.backgroundRange,\n            auxRange: options.auxRange === undefined ? { min: 0, max: this.pal.length - 1 } : options.auxRange,\n            borderRange: options.borderRange === undefined ? { min: 0, max: this.pal.length - 1 } : options.borderRange,\n            colors: this.block.colors,\n            colorsRange: options.colorsRange === undefined ? { min: 0, max: this.pal.length - 1 } : options.colorsRange\n        };\n\n        this.paletteChoices.colors = options.colors === undefined ?\n            (this.block.colors - (this.paletteChoices.background ? 1 : 0) - (this.paletteChoices.aux ? 1 : 0) - (this.paletteChoices.border ? 1 : 0)) :\n            options.colors;\n        this.preparePixelPaletteChoices();\n\n        // some basic sanity checks\n        runtime_assert(this.pal.length > this.paletteChoices.backgroundRange.max - this.paletteChoices.backgroundRange.min);\n        runtime_assert(this.pal.length > this.paletteChoices.auxRange.max - this.paletteChoices.auxRange.min);\n        runtime_assert(this.pal.length > this.paletteChoices.borderRange.max - this.paletteChoices.borderRange.min);\n    }\n    chooseMin(available: boolean, range: PaletteRange, current?: number): number {\n        if (!available)\n            return current;\n        if (current === undefined)\n            return range.min;\n        return Math.min(current, range.min);\n    }\n    chooseMax(available: boolean, range: PaletteRange, current?: number): number {\n        if (!available)\n            return current;\n        if (current === undefined)\n            return range.max;\n        return Math.max(current, range.max);\n    }\n    prepareMinMax(background: boolean, aux: boolean, border: boolean): PaletteRange {\n        let chosenMin: number | undefined = this.chooseMin(background, this.paletteChoices.backgroundRange);\n        chosenMin = this.chooseMin(aux, this.paletteChoices.auxRange, chosenMin);\n        chosenMin = this.chooseMin(border, this.paletteChoices.borderRange, chosenMin);\n        //chosenMin = this.chooseMin(true, this.paletteChoices.colorsRange, chosenMin); // do not include pixel choices in this range\n        chosenMin = chosenMin === undefined ? 0 : chosenMin;\n\n        let chosenMax: number | undefined = this.chooseMax(background, this.paletteChoices.backgroundRange);\n        chosenMax = this.chooseMax(aux, this.paletteChoices.auxRange, chosenMax);\n        chosenMax = this.chooseMax(border, this.paletteChoices.borderRange, chosenMax);\n        //chosenMax = this.chooseMax(true, this.paletteChoices.colorsRange, chosenMax); // do not include pixel choices in this range\n        chosenMax = chosenMax === undefined ? (this.pal.length - 1) : chosenMax;\n\n        return {min: chosenMin, max: chosenMax};\n    }\n    override prepareGlobalColorChoices(): void {\n        let range = this.prepareMinMax(true, true, true);\n        let palSubset = this.pal.slice(range.min, range.max + 1);\n\n        // by default the choices result is ranked by color intensity\n        let choices = reducePaletteChoices(\n            this.ref,\n            palSubset,\n            palSubset.length,  // rank the entire palette subset (because restricted palettes may have to fallback)\n            1,\n            this.errfn);\n\n        // Need a ranking based on color usage, because if the color\n        // is selectable by a pixel then the most prominent selectable\n        // color should be chosen (to not waste a color for intensity\n        // reasons when a color is most useful as a pixel color choice);\n        // but if the color is not selectable by the color then fallback\n        // to color intensity (based on which top N colors are the\n        // most likely to be compatible with the picture);\n        let histoRankedChoices = choices.slice(0, choices.length);\n        histoRankedChoices.sort((a,b) => b.count - a.count);\n\n        this.foundColorsByUsage = histoRankedChoices.slice(0, histoRankedChoices.length);\n        this.foundColorsByColorIntensity = choices.slice(0, choices.length);\n\n        // these are the possible choices for colors\n        let ranges: { id: number, selectable: boolean, range: PaletteRange }[] = [\n            { id: 0, selectable: this.paletteChoices.background, range: this.paletteChoices.backgroundRange },\n            { id: 1, selectable: this.paletteChoices.aux, range: this.paletteChoices.auxRange },\n            { id: 2, selectable: this.paletteChoices.border, range: this.paletteChoices.borderRange }\n        ];\n\n        // sort by the follow criteria:\n        // 1. colors that can be selected by pixels have priority over those that do not\n        // 2. colors that have the most restricted palettes\n        // 3. by id (if all other choices are equal)\n        ranges.sort((a,b) =>\n            (a.selectable == b.selectable) ? \n                (((a.range.max - a.range.min) == (b.range.max - b.range.min)) ?\n                    a.id - b.id :\n                    (a.range.max - a.range.min) - (b.range.max - b.range.min)) :\n                (a.selectable ? -1 : 1));\n\n        let assignId = (choice: ColorChoice, option: { id: number, selectable: boolean, range: PaletteRange }) => {\n            let index = choice.ind + range.min; // palette might be a subset\n\n            // do not select the choice if the palette range restrictions do not allow it\n            if ((index < option.range.min) || (index > option.range.max))\n                return false;\n\n            switch (option.id) {\n                case 0: this.backgroundColor = index; break;\n                case 1: this.auxColor = index; break;\n                case 2: this.borderColor = index; break;\n            }\n            return true;\n        };\n\n        let findBestChoice = (searchList: ColorChoice[], altList: ColorChoice[], option: { id: number, selectable: boolean, range: PaletteRange }) => {\n            // based on the priority of the ranges, pick/assign a choice color to each\n            // option in the range, starting with the most important first (as\n            // defined by the sort order)\n            for (let c = 0; c < searchList.length; ++c) {\n                let choice = searchList[c];\n\n                // attempt to assign the choice to the color option\n                if (!assignId(choice, option))\n                    continue;   // if didn't get used, try next color\n\n                // find this color choice in the alternative array (so it can be removed)\n                let found = altList.findIndex((x) => x.ind == choice.ind);\n\n                // remove the entry from the alternatively ranked list\n                runtime_assert(found >= 0);\n                altList.splice(found, 1);\n\n                // prevent this choice from being used again\n                searchList.splice(c, 1);\n                break;\n            }\n        };\n\n        let firstNonSelectableColorFound = false;\n\n        // try to match a color choice with the options available\n        for (let i = 0; i < ranges.length; ++i) {\n            let option = ranges[i];\n\n            if ((!option.selectable) && (!firstNonSelectableColorFound)) {\n                // found all the required colors that can be chosen by a\n                // pixel so now re-rank the remaining color choices, putting\n                // the top N \"compatible\" based on picture histo usage at the\n                // top of the array, but sorted by intensity\n                // (where N is the number of remaining \"other\" colors to choose);\n                let topNChoices : { priority: number, choice: ColorChoice }[] = []\n                for (let c = 0; c < ranges.length - i; ++c) {\n                    if (c >= histoRankedChoices.length)\n                        continue; // make sure the colors are not exhausted\n\n                    // this color is high priority to pick\n                    let topChoice = histoRankedChoices[c];\n                    let priority = choices.findIndex((x) => x.ind == topChoice.ind);\n                    runtime_assert(priority >= 0);\n                    topNChoices.push({priority, choice: topChoice});\n                    // removing the choice from the list is okay because it's going to be\n                    // re-inserted at the top of the new choices list\n                    choices.splice(priority, 1);\n                }\n\n                // sort the top choices by intensity\n                topNChoices.sort((a,b) => a.priority - b.priority);\n\n                // put the top N at the front of the choices list\n                choices = (topNChoices.map((x) => x.choice)).concat(choices);\n                firstNonSelectableColorFound = true;\n            }\n\n            findBestChoice((option.selectable ? histoRankedChoices : choices), (option.selectable ? choices : histoRankedChoices), option);\n            // console.log(\"findBestChoice\", i, option, histoRankedChoices, choices);\n        }\n\n        if (this.paletteChoices.background)\n            this.globalValid.push(this.backgroundColor);\n        if (this.paletteChoices.aux)\n            this.globalValid.push(this.auxColor);\n        if (this.paletteChoices.border)\n            this.globalValid.push(this.borderColor);\n\n        if (this.paletteChoices.background)\n            this.pixelPaletteChoices = this.spliceColor(this.backgroundColor, this.pixelPaletteChoices);\n        if (this.paletteChoices.aux)\n            this.pixelPaletteChoices = this.spliceColor(this.auxColor, this.pixelPaletteChoices);\n        if (this.paletteChoices.border)\n            this.pixelPaletteChoices = this.spliceColor(this.borderColor, this.pixelPaletteChoices);\n    }\n    override allocateParams(): void {\n        this.blockParams = new Uint32Array(this.paramInfo.block ? this.block.size : 0);\n        this.cbParams = new Uint32Array(this.paramInfo.cb ? this.cb.size : 0);\n        this.cellParams = new Uint32Array(this.paramInfo.cell ? this.cell.size : 0);\n        this.extraParams = new  Uint32Array(this.paramInfo.extra);\n\n        // make the default params refer to the block params\n        this.params = this.blockParams;\n    }\n\n    imageIndexToInfo(index: number, info: BlockInfo): { column: number, row: number } {\n        let column = Math.floor(index / info.w) % info.columns;\n        let row = Math.floor(index / (this.width * info.h));\n        return { column, row };\n    }\n    imageIndexToBlockInfo(index: number): { column: number, row: number } {\n        return this.imageIndexToInfo(index, this.block);\n    }\n    imageIndexToCbInfo(index: number): { column: number, row: number } {\n        return this.imageIndexToInfo(index, this.cb);\n    }\n    imageIndexToCellInfo(index: number): { column: number, row: number } {\n        return this.imageIndexToInfo(index, this.cell);\n    }\n    imageIndexToOffset(index: number, info: BlockInfo): number {\n        let { column, row } = this.imageIndexToInfo(index, info);\n        let offset = row * info.columns + column;\n        return offset;\n    }\n\n    imageIndexToBlockOffset(index: number): number {\n        return this.imageIndexToOffset(index, this.block);\n    }\n    imageIndexToCbOffset(index: number): number {\n        return this.imageIndexToOffset(index, this.cb);\n    }\n    imageIndexToCellOffset(index: number): number {\n        return this.imageIndexToOffset(index, this.cell);\n    }\n\n    imageIndexToXY(index: number): { x: number, y: number} {\n        return { x: index % this.width, y: Math.floor(index / this.width) };\n    }\n    xyToImageIndex(x: number, y: number): number | undefined {\n        if ((x < 0) || (y < 0))\n            return undefined;\n        if ((x >= this.width) || (y >= this.height))\n            return undefined;\n        return y * this.width + x;\n    }\n\n    offsetToInfo(offset: number, info: BlockInfo): { column: number, row: number } {\n        let column = offset % info.columns;\n        let row = Math.floor(offset / info.columns);\n        return { column, row };\n    }\n    offsetToBlockInfo(offset: number): { column: number, row: number } {\n        return this.offsetToInfo(offset, this.block);\n    }\n    offsetToCbInfo(offset: number): { column: number, row: number } {\n        return this.offsetToInfo(offset, this.cb);\n    }\n    offsetToCellInfo(offset: number): { column: number, row: number } {\n        return this.offsetToInfo(offset, this.cell);\n    }\n\n    offsetToImageIndex(offset: number, info: BlockInfo): number {\n        let { column, row } = this.offsetToInfo(offset, info);\n        let index = (row * this.width * info.h) + (column * info.w);\n        return index;\n    }\n    blockOffsetToImageIndex(offset: number): number {\n        return this.offsetToImageIndex(offset, this.block);\n    }\n    cbOffsetToImageIndex(offset: number): number {\n        return this.offsetToImageIndex(offset, this.cb);\n    }\n    cellOffsetToImageIndex(offset: number): number {\n        return this.offsetToImageIndex(offset, this.cell);\n    }\n\n    override currentColorAtXY(x: number, y: number, orColor?: number): number | undefined {\n        let imageIndex = this.xyToImageIndex(x, y);\n        return (imageIndex === undefined ? orColor : this.indexed[imageIndex]);\n    }\n\n    addToHistogramFromCurrentColor(color: number, histogram: Uint32Array) : void {\n        runtime_assert(color < histogram.length);\n        histogram[color] += this.histogramScoreCurrent;\n    }\n\n    override addToHistogramAtXYFromCurrentColor(x: number, y: number, color: number | undefined, histogram: Uint32Array): void {\n        if (color === undefined)\n            return;\n        this.addToHistogramFromCurrentColor(color, histogram);\n    }\n\n    addToHistogramAtOffsetFromCurrentColor(offset: number, info: ExtendedBlockInfo, histogram: Uint32Array, colors?: number[], orColor?: number, fnAddToHistogram?: AddToHistogramFromCurrentColorAtHandler): void {\n        let imageIndex = this.offsetToImageIndex(offset, info);\n        let start = this.imageIndexToXY(imageIndex);\n\n        for (let y = start.y - info.yb; y < start.y + info.h + info.yb; ++y) {\n            for (let x = start.x - info.xb; x < start.x + info.w + info.xb; ++x) {\n                let color = this.currentColorAtXY(x, y, orColor);\n                if (colors !== undefined) {\n                    if (colors.find((x) => x == color) === undefined)\n                        continue;\n                }\n\n                if (fnAddToHistogram === undefined)\n                    this.addToHistogramAtXYFromCurrentColor(x, y, color, histogram);\n                else\n                    fnAddToHistogram(x, y, color, histogram);\n            }\n        }\n    }\n    addToBlockHistogramFromCurrentColor(offset: number, histogram: Uint32Array, colors?: number[], orColor?: number, fnAddToHistogram?: AddToHistogramFromCurrentColorAtHandler): void {\n        return this.addToHistogramAtOffsetFromCurrentColor(offset, this.block, histogram, colors, orColor, fnAddToHistogram);\n    }\n    addToCbHistogramFromCurrentColor(offset: number, histogram: Uint32Array, colors?: number[], orColor?: number, fnAddToHistogram?: AddToHistogramFromCurrentColorAtHandler): void {\n        return this.addToHistogramAtOffsetFromCurrentColor(offset, this.cb, histogram, colors, orColor, fnAddToHistogram);\n    }\n    addToCellHistogramFromCurrentColor(offset: number, histogram: Uint32Array, colors?: number[], orColor?: number, fnAddToHistogram?: AddToHistogramFromCurrentColorAtHandler): void {\n        return this.addToHistogramAtOffsetFromCurrentColor(offset, this.cell, histogram, colors, orColor, fnAddToHistogram);\n    }\n\n    scoreColorAtXYFrom(x: number, y: number, scores: Uint32Array, colors: number[] | undefined, from: Uint32Array): ClosestScore | undefined {\n        let imageIndex = this.xyToImageIndex(x, y);\n\n        if (imageIndex === undefined)\n            return undefined;\n\n        let rgb = from[imageIndex];\n\n        let colorToPalIndex = (i: number) => {\n            return colors === undefined ? i : colors[i];\n        };\n\n        let closestColor = NaN;\n        let closestScore = NaN;\n        for (let i = 0; i < (colors === undefined ? scores.length : colors.length); ++i) {\n            let rgbPalette = this.pal[colorToPalIndex(i)];\n            let score = this.errfn(rgb, rgbPalette);\n            runtime_assert(colorToPalIndex(i) < scores.length);\n            scores[colorToPalIndex(i)] += score;\n            if ((score < closestScore) || (Number.isNaN(closestScore))) {\n                closestScore = score;\n                closestColor = colorToPalIndex(i);\n            }\n        }\n\n        return (Number.isNaN(closestColor) ? undefined : { closestColor: closestColor, closestScore: closestScore });\n    }\n    scoreColorAtXYFromAlt(x: number, y: number, scores: Uint32Array, colors?: number[]): ClosestScore | undefined {\n        return this.scoreColorAtXYFrom(x, y, scores, colors, this.alt);\n    }\n    scoreColorAtXYFromRef(x: number, y: number, scores: Uint32Array, colors?: number[]): ClosestScore | undefined {\n        return this.scoreColorAtXYFrom(x, y, scores, colors, this.ref);\n    }\n\n    mergeHistogram(dest: Uint32Array, source1: Uint32Array, source2: Uint32Array, colors?: number[]): void {\n        runtime_assert(source1.length == source2.length);\n        runtime_assert(dest.length == source1.length);\n\n        if (colors === undefined) {\n            for (let i = 0; i < dest.length; ++i) {\n                dest[i] = source1[i] + source2[i];\n            }\n            return;\n        }\n\n        for (let i = 0; i < colors.length; ++i) {\n            dest[colors[i]] = source1[colors[i]] + source2[colors[i]];\n        }\n    }\n\n    addToHistogramFromClosest(closest: ClosestScore, histogram: Uint32Array): void {\n        histogram[closest.closestColor] += 1 + this.noise;\n    }\n\n    override addToHistogramFromClosestAtXY(x: number, y: number, closest: ClosestScore | undefined, histogram: Uint32Array): void {\n        if (closest === undefined)\n            return;\n        return this.addToHistogramFromClosest(closest, histogram);\n    }\n\n    addToHistogramAtOffsetFrom(\n        offset: number,\n        info: ExtendedBlockInfo,\n        histogram: Uint32Array,\n        scores: Uint32Array,\n        colors: number[] | undefined,\n        from: Uint32Array,\n        fnAddToHistogram?: AddToHistogramFromClosestAtHandler) : ScoredColorChoice[] {\n\n        let total = 0;\n\n        let imageIndex = this.offsetToImageIndex(offset, info);\n        let start = this.imageIndexToXY(imageIndex);\n\n        for (let y = start.y - info.yb; y < start.y + info.h + info.yb; ++y) {\n            for (let x = start.x - info.xb; x < start.x + info.w + info.xb; ++x) {\n                let closest = this.scoreColorAtXYFrom(x, y, scores, colors, from);\n                if (fnAddToHistogram === undefined)\n                    this.addToHistogramFromClosestAtXY(x, y, closest, histogram);\n                else\n                    fnAddToHistogram(x, y, closest, histogram);\n            }\n        }\n\n        let scored = (colors === undefined ? (range(0, scores.length).map((x) => { return { ind: x, score: scores[x], count: histogram[x] }; })) : (colors.map((x) => { return { ind: x, score: scores[x], count: histogram[x] }; })));\n        return scored;\n    }\n\n    addToBlockHistogramFrom(offset: number, histogram: Uint32Array, scores: Uint32Array, colors: number[] | undefined, from: Uint32Array, fnAddToHistogram?: AddToHistogramFromClosestAtHandler) : ScoredColorChoice[] {\n        return this.addToHistogramAtOffsetFrom(offset, this.block, histogram, scores, colors, from, fnAddToHistogram);\n    }\n    addToCbHistogramFrom(offset: number, histogram: Uint32Array, scores: Uint32Array, colors: number[] | undefined, from: Uint32Array, fnAddToHistogram?: AddToHistogramFromClosestAtHandler) : ScoredColorChoice[] {\n        return this.addToHistogramAtOffsetFrom(offset, this.cb, histogram, scores, colors, from, fnAddToHistogram);\n    }\n    addToCellHistogramFrom(offset: number, histogram: Uint32Array, scores: Uint32Array, colors: number[] | undefined, from: Uint32Array, fnAddToHistogram?: AddToHistogramFromClosestAtHandler) : ScoredColorChoice[] {\n        return this.addToHistogramAtOffsetFrom(offset, this.cell, histogram, scores, colors, from, fnAddToHistogram);\n    }\n\n    addToBlockHistogramFromAlt(offset: number, histogram: Uint32Array, scores: Uint32Array, colors?: number[], fnAddToHistogram?: AddToHistogramFromClosestAtHandler) : ScoredColorChoice[] {\n        return this.addToHistogramAtOffsetFrom(offset, this.block, histogram, scores, colors, this.alt, fnAddToHistogram);\n    }\n    addToCbHistogramFromAlt(offset: number, histogram: Uint32Array, scores: Uint32Array, colors?: number[], fnAddToHistogram?: AddToHistogramFromClosestAtHandler) : ScoredColorChoice[] {\n        return this.addToHistogramAtOffsetFrom(offset, this.cb, histogram, scores, colors, this.alt, fnAddToHistogram);\n    }\n    addToCellHistogramFromAlt(offset: number, histogram: Uint32Array, scores: Uint32Array, colors?: number[], fnAddToHistogram?: AddToHistogramFromClosestAtHandler) : ScoredColorChoice[] {\n        return this.addToHistogramAtOffsetFrom(offset, this.cell, histogram, scores, colors, this.alt, fnAddToHistogram);\n    }\n\n    addToBlockHistogramFromRef(offset: number, histogram: Uint32Array, scores: Uint32Array, colors?: number[], fnAddToHistogram?: AddToHistogramFromClosestAtHandler) : ScoredColorChoice[] {\n        return this.addToHistogramAtOffsetFrom(offset,  this.block, histogram, scores, colors,this.ref, fnAddToHistogram);\n    }\n    addToCbHistogramFromRef(offset: number, histogram: Uint32Array, scores: Uint32Array, colors?: number[], fnAddToHistogram?: AddToHistogramFromClosestAtHandler) : ScoredColorChoice[] {\n        return this.addToHistogramAtOffsetFrom(offset, this.cb, histogram, scores, colors, this.ref, fnAddToHistogram);\n    }\n    addToCellHistogramFromRef(offset: number, histogram: Uint32Array, scores: Uint32Array, colors?: number[], fnAddToHistogram?: AddToHistogramFromClosestAtHandler) : ScoredColorChoice[] {\n        return this.addToHistogramAtOffsetFrom(offset, this.cell, histogram, scores, colors, this.ref, fnAddToHistogram);\n    }\n\n    getScoredChoicesByCount(scored: ScoredColorChoice[]): ScoredColorChoice[] {\n        let result = scored.filter((x) => x.count > 0);\n        result.sort((a, b) => b.count - a.count);\n        return result;\n    }\n    getScoredChoicesByScore(scored: ScoredColorChoice[]): ScoredColorChoice[] {\n        let result = scored.filter((x) => x.count > 0);\n        result.sort((a, b) => a.score - b.score);\n        return result;\n    }\n\n    updateColorParam(offset: number, params: Uint32Array, colorChoices: number[], overrideFilter?: number, overrideBits?: number): void {\n        runtime_assert(offset < params.length);\n\n        if (colorChoices.length < 1) {\n            params[offset] = 0;\n            return;\n        }\n\n        let value = 0;\n        for (let i = colorChoices.length - 1; i >= 0; --i) {\n            value <<= (overrideBits === undefined ? this.paletteBits : overrideBits);\n            value |= colorChoices[i] & (overrideFilter === undefined ? this.paletteBitFilter : overrideFilter);\n        }\n        params[offset] = value;\n    }\n    updateBlockColorParam(offset: number, colorChoices: number[], overrideFilter?: number, overrideBits?: number): void {\n        this.updateColorParam(offset, this.blockParams, colorChoices, overrideFilter, overrideBits);\n    }\n    updateCbColorParam(offset: number, colorChoices: number[], overrideFilter?: number, overrideBits?: number): void {\n        this.updateColorParam(offset, this.cbParams, colorChoices, overrideFilter, overrideBits);\n    }\n    updateCellColorParam(offset: number, colorChoices: number[], overrideFilter?: number, overrideBits?: number): void {\n        this.updateColorParam(offset, this.cellParams, colorChoices, overrideFilter, overrideBits);\n    }\n\n    extractColorsFromParams(offset: number, params: Uint32Array, totalToExtract: number, overrideFilter?: number, overrideBits?: number): number[] {\n        return extractColorsFromParams(offset, params, totalToExtract, overrideFilter === undefined ? this.paletteBitFilter : overrideFilter, overrideBits === undefined ? this.paletteBits : overrideBits);\n    }\n    extractColorsFromBlockParams(offset: number, totalToExtract: number, overrideFilter?: number, overrideBits?: number): number[] {\n        return extractColorsFromParams(offset, this.blockParams, totalToExtract, overrideFilter === undefined ? this.paletteBitFilter : overrideFilter, overrideBits === undefined ? this.paletteBits : overrideBits);\n    }\n    extractColorsFromCbParams(offset: number, totalToExtract: number, overrideFilter?: number, overrideBits?: number): number[] {\n        return extractColorsFromParams(offset, this.cbParams, totalToExtract, overrideFilter === undefined ? this.paletteBitFilter : overrideFilter, overrideBits === undefined ? this.paletteBits : overrideBits);\n    }\n    extractColorsFromCellParams(offset: number, totalToExtract: number, overrideFilter?: number, overrideBits?: number): number[] {\n        return extractColorsFromParams(offset, this.cellParams, totalToExtract, overrideFilter === undefined ? this.paletteBitFilter : overrideFilter, overrideBits === undefined ? this.paletteBits : overrideBits);\n    }\n\n    override commit(): void {\n        // default is to reverse order of the guessing as some grander choices\n        // may affect subsequent fine-grain choices\n        this.guessExtraParams();\n        this.guessCellParams();\n        this.guessCbParams();\n        this.guessBlockParams();\n        this.firstCommit = false;\n    }\n\n    override getValidColors(imageIndex: number): number[] {\n        let offset = this.imageIndexToBlockOffset(imageIndex);\n\n        if (this.fullPaletteMode)\n            return this.pixelPaletteChoices;\n\n        let extracted = this.extractColorsFromBlockParams(offset, this.paletteChoices.colors);\n        if ((this.globalValid.length == 0) && (extracted.length <= this.paletteChoices.colors))\n            return extracted;\n\n        let valid: number[] = this.globalValid.slice(0, this.globalValid.length);\n        valid.push(...extracted);\n        valid = valid.slice(0, this.globalValid.length + this.paletteChoices.colors);\n        return valid;\n    }\n\n    override guessBlockParams(): void {\n        for (let i = 0; i < this.blockParams.length; ++i) {\n            this.guessBlockParam(i);\n        }\n    }\n    override guessCbParams(): void {\n        for (let i = 0; i < this.cbParams.length; ++i) {\n            this.guessCbParam(i);\n        }\n    }\n    override guessCellParams(): void {\n        for (let i = 0; i < this.cellParams.length; ++i) {\n            this.guessCellParam(i);\n        }\n    }\n    override guessExtraParams(): void {\n        for (let i = 0; i < this.extraParams.length; ++i) {\n            this.guessExtraParam(i);\n        }\n    }\n\n    override guessBlockParam(offset: number): void {\n\n        // nothing to store if the pixel can store the direct palette value\n        if (this.fullPaletteMode)\n            return;\n\n        // reset histogram values\n        this.histogram.fill(0);\n        this.scores.fill(0);\n\n        // rank all colors within the size of the block (and bordering values)\n        if (!this.firstCommit)\n            this.addToBlockHistogramFromCurrentColor(offset, this.histogram, this.pixelPaletteChoices);\n        let scored = this.addToBlockHistogramFrom(offset, this.histogram, this.scores, this.pixelPaletteChoices, this.firstCommit ? this.ref : this.alt);\n\n        // never choose the colors that are always valid and available\n        // for every pixel (i.e. why waste the screen ram or color block\n        // ram on a color that is always available everywhere)\n\n        // get best choices for sub-block\n        let choices = this.getScoredChoicesByCount(scored);\n\n        let colors = (choices.map((x) => { return x.ind; } )).slice(0, (this.block.colors - this.globalValid.length));\n\n        while (colors.length < (this.block.colors - this.globalValid.length)) {\n            colors.push( this.pixelPaletteChoices[0] || this.backgroundColor );\n        }\n\n        colors = colors.sort((a, b) => a - b);\n        this.updateBlockColorParam(offset, colors);\n    }\n    override guessCbParam(offset: number): void {\n    }\n    override guessCellParam(offset: number): void {\n    }\n    override guessExtraParam(offset: number): void {\n    }\n}\n", "\nimport { ERROR_FUNCTIONS, getRGBAErrorPerceptual, reducePalette } from '../common/color';\nimport { DithertronSettings, PixelsAvailableMessage } from '../common/types';\nimport { SYSTEMS } from '../settings/systems';\nimport * as canvas from './canvas';\n\n/*\nconst emglobal : any = this['window'] || (this as any)['global'] || this;\nconst ENVIRONMENT_IS_WEB = typeof window === 'object';\nconst ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';\n*/\n\n//\n\nexport const MAX_ITERATE_COUNT = 100;\n\nconst TEMPERATURE_START_ITERATIONS = 10;\nconst TEMPERATURE_STEP = 0.01;\n\nexport interface DithertronInterface {\n    iterate(): void;\n}\n\nexport class Dithertron implements DithertronInterface {\n    sysparams: DithertronSettings = SYSTEMS[0];\n    dithcanv: canvas.DitheringCanvas | null = null;\n    sourceImageData: Uint32Array | null = null;\n    pixelsAvailable: ((msg: PixelsAvailableMessage) => void) | null = null;\n    timer: any;\n\n    setSettings(sys: DithertronSettings) {\n        this.sysparams = Object.assign({}, sys); // clone settings\n    }\n    setSourceImage(imageData: Uint32Array) {\n        this.sourceImageData = imageData;\n    }\n    iterate(): boolean {\n        if (this.dithcanv == null) {\n            var sys = this.sysparams;\n            if (!sys) throw new Error(\"no sysparams\");\n            if (!this.sourceImageData) throw new Error(\"no sourceImageData\");\n            var pal = new Uint32Array(sys.pal);\n            var errfn = (ERROR_FUNCTIONS as any)[sys.errfn || 'perceptual'] || getRGBAErrorPerceptual;\n            if (sys.reduce) {\n                pal = reducePalette(this.sourceImageData, pal,\n                    sys.reduce, sys.paletteDiversity || 0, errfn);\n            }\n            if (sys.extraColors) {\n                let pal2 = new Uint32Array(pal.length + sys.extraColors);\n                pal2.set(pal);\n                pal = pal2;\n            }\n            var convFunction = canvas[sys.conv];\n            if (!convFunction) throw new Error(\"no convFunction for \" + sys.conv);\n            this.dithcanv = new convFunction(this.sourceImageData, sys.width, pal);\n            if (!this.dithcanv) throw new Error(\"no convFunction() for \" + sys.conv);\n            this.dithcanv.sys = sys;\n            this.dithcanv.errfn = errfn;\n            this.dithcanv.noise = sys.noise ? (1 << sys.noise) : 0;\n            this.dithcanv.diffuse = (sys.diffuse || 0) + 0;\n            this.dithcanv.ordered = (sys.ordered || 0) + 0;\n            this.dithcanv.ditherfn = sys.ditherfn || [];\n            this.dithcanv.init();\n        }\n        this.dithcanv.iterate();\n        this.dithcanv.noise >>= 1; // divide by 2\n        if (this.dithcanv.iterateCount >= TEMPERATURE_START_ITERATIONS) {\n            this.dithcanv.errorThreshold += TEMPERATURE_STEP;\n        }\n        var final = this.dithcanv.changes == 0 || this.dithcanv.iterateCount > MAX_ITERATE_COUNT;\n        if (this.pixelsAvailable != null) {\n            this.pixelsAvailable({\n                img: this.dithcanv.img,\n                width: this.dithcanv.width,\n                height: this.dithcanv.height,\n                pal: this.dithcanv.pal,\n                indexed: this.dithcanv.indexed,\n                content: this.dithcanv.content(),\n                final: final,\n            });\n        }\n        return !final;\n    }\n    iterateIfNeeded() {\n        if (this.iterate()) {\n            //console.log(this.dithcanv.noise, this.dithcanv.changes, this.dithcanv.iterateCount);\n        } else {\n            this.stop();\n            console.log('stop', this.dithcanv?.iterateCount);\n        }\n    }\n    clear() {\n        this.dithcanv = null;\n    }\n    restart() {\n        this.clear();\n        this.start();\n    }\n    stop() {\n        clearTimeout(this.timer);\n        this.timer = undefined;\n    }\n    start() {\n        if (this.sysparams == null) return;\n        if (this.sourceImageData == null) return;\n        if (this.timer == null) {\n            const msec = 50;\n            var fn = () => {\n                this.timer = setTimeout(fn, msec);\n                this.iterateIfNeeded();\n            }\n            this.timer = setTimeout(fn, msec);\n        }\n    }\n}\n\n", "import { Dithertron } from \"../dither/dithertron\";\nimport { PixelsAvailableMessage } from \"../common/types\";\n\n//declare function postMessage(msg:any):void;\n\nvar worker_dtron = new Dithertron();\n\nonmessage = function (e) {\n    if (e && e.data) {\n        console.log(e.data.cmd);\n        switch (e.data.cmd) {\n            case 'restart': return worker_dtron.restart();\n            case 'setSettings': return worker_dtron.setSettings(e.data.data);\n            case 'setSourceImage': return worker_dtron.setSourceImage(e.data.data);\n        }\n    }\n}\n\nworker_dtron.pixelsAvailable = (msg: PixelsAvailableMessage) => {\n    postMessage(msg);\n};\n"],
  "mappings": "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,IAAU;AAAA,IAAU;AAAA,IACtJ;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IACtJ;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IACtJ;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IACtJ;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IACtJ;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IACtJ;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IACtJ;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IACtJ;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,IAAU;AAAA,I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",
  "names": ["range", "x", "scored"]
}
